<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android 12 刷入 Magisk 模块后无法开机的解决方法</title>
    <url>/2022/03/15/Android%2012%20%E5%88%B7%E5%85%A5%20Magisk%20%E6%A8%A1%E5%9D%97%E5%90%8E%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>笔者的机器是 OnePlus 8 T, 这几天更新了Color OS 12公测版（Based Android 12），作为一个酷安机佬，自然是忍不住刷机的冲动。</p>
<p>本地升级之后使用体验比氢氧好得多，只是耗电量陡增。看酷安的机友说，从H2OS更新到颜色系统，最好是进行一次双清。俺寻思从小到大刷机这么七八年了，什么大风大浪没见过？数据备份完成之后就是一把梭直接重启到 REC 模式双清数据。</p>
<p>然后就是大家喜闻乐见的环节：提取 boot.img 文件，写入 Magisk，进入 fastboot 模式刷入 boot.img 获取 root 权限。</p>
<p>由于 Android 12 没有可用的 TWRP，这对于需要折腾 Magisk 和 Xposed 的机友来说实在是不太友好，一个失误操作直接卡第一屏，就可以准备后事哦不高通9008了。（<strong>比如我，闷声作大死，第二天要打工还刷机，直接给我整到凌晨四点。</strong>）</p>
<p>由于 Magisk 只是修改了系统的 boot 分区，可以通过重新刷入官方 ROM 的 boot.img 重新开机，但是这样开机之后，是没有 root 权限的，也没有办法删除 Magisk 里面不兼容的 Module。之后如果然后手动重新给 boot.img 打上 root 补丁，又会陷入无法开机的死循环中。最后没办法只能双清重刷，非常难受。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>但是！但是！但是！可喜可贺的是，在 Android 12 下的 Magisk 更新了一个非常有用的功能（准确来说应该是在 Magisk 23 之后的版本引入的特性功能）：<strong>如果 Magisk 检测到手机进入安全模式之后，就会自动禁用所有模块（并不会删除）</strong>。这简直就是没有 TWRP 机友的福音！</p>
<h2 id="安全模式救砖："><a href="#安全模式救砖：" class="headerlink" title="安全模式救砖："></a>安全模式救砖：</h2><p>具体来说，就是如果刷入了不兼容的 Module，然后开机卡第一屏，那么可以强制关机，然后在关机状态下，直接进入安全模式，Magisk 就会禁用所有的 Modules，然后再次重启机器进入正常模式，这个时候因为所有的 Modules 都是禁用状态，所以可以正常开机，开机之后机器还是 root 状态，这时候直接删掉不兼容的 Module 就行了。</p>
<ol>
<li>设备关机状态下，按电源键开机</li>
<li>待出现 bootloader 已解锁的安全提示后，直接按住“音量减”键，直到进入桌面</li>
<li>屏幕左下方显示“安全模式”即表示成功</li>
</ol>
<p>PS： 上面介绍的是 Android 官方的通用方式，如果你的设备比较特别的话，可能需要自己 Google 一下如何进入安全模式。</p>
<p>PPS：另外再说一种有点暴力和局限性的方法，但是比上面这个更彻底，开机之后 Magisk 会删掉所有 Modules，当然也会丢失 root 权限，需要重新给 boot.img 打补丁来 root 设备，但是总比变砖或者线刷要好吧。</p>
<h2 id="其他救砖方法"><a href="#其他救砖方法" class="headerlink" title="其他救砖方法"></a>其他救砖方法</h2><p>这个方法从是让 ADB 等待设备进入引导屏幕，然后 ADB 开始工作， ADB 会删除所有已安装的 Magisk Modules 来确保机器能够进入系统。</p>
<ol>
<li><p>确保设备在关机状态下</p>
</li>
<li><p>使用数据线将手机连接到已经安装了 ADB 的电脑上</p>
</li>
<li><p>电脑进入 ADB 文件夹，执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb wait-for-device shell magisk --remove-modules</span><br></pre></td></tr></table></figure></li>
<li><p>按住电源键开机，并且不松开，直到进入桌面</p>
</li>
</ol>
<p>如果上面这两种方法都无法拯救你的爱机的话，就只能9008了。具体见<a href="https://yun.daxiaamu.com/OnePlus_Roms/">大侠阿木的博客</a>，另外，强推阿木大佬的一加全能盒子！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>新的一年没啥好祝福大🔥的，只好祝大家刷机必卡米，9008一路顺畅！</p>
]]></content>
      <categories>
        <category>Android 12</category>
        <category>Color OS</category>
        <category>刷机</category>
        <category>一加</category>
      </categories>
      <tags>
        <tag>Android 12</tag>
        <tag>Color OS</tag>
        <tag>刷机</tag>
        <tag>一加</tag>
      </tags>
  </entry>
  <entry>
    <title>DIV元素中的文本居中</title>
    <url>/2022/02/24/DIV%E5%85%83%E7%B4%A0%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="DIV元素中的文本居中"><a href="#DIV元素中的文本居中" class="headerlink" title="DIV元素中的文本居中"></a>DIV元素中的文本居中</h1><p>在样式布局中，我们经常碰到需要将元素居中。</p>
<p>通过css实现元素的水平居中较为简单：对文本，只需要对其父级元素设置<code>text-align: center;</code>，而对div等块级元素，只需要设置其 left 和 right 的 <code>margin: auto;</code>。</p>
<p>要实现元素的垂直居中，很容易便会想到<code>vertical-align</code>属性，但是该属性只对拥有<code>valign</code>特性的元素才生效，例如表格元素中的<code>&lt;td&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;caption&gt;</code>等。而像<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>这样的元素是没有<code>valign</code>特性的，使用该属性对这些元素并不起作用。</p>
<p>因此我们需要通过别的方法去实现元素的垂直居中，我总结了几种了常用垂直居中方法在下面。</p>
<h1 id="单行文本垂直居中"><a href="#单行文本垂直居中" class="headerlink" title="单行文本垂直居中"></a>单行文本垂直居中</h1><p>对于单行文本，我们只需要将文本行高(line-height)和所在区域高度(height)设为一致即可：</p>
   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">	这是单行文本垂直居中</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">line-height</span>: <span class="number">100px</span>; <span class="comment">/*设置line-height与父级元素的height相等*/</span></span></span><br><span class="line"><span class="language-css">	<span class="attribute">text-align</span>: center; <span class="comment">/*设置文本水平居中*/</span></span></span><br><span class="line"><span class="language-css">	<span class="attribute">overflow</span>: hidden; <span class="comment">/*防止内容超出容器或者产生自动换行*/</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="多行文本垂直居中"><a href="#多行文本垂直居中" class="headerlink" title="多行文本垂直居中"></a>多行文本垂直居中</h1><p>多行文本垂直居中分为两种情况：</p>
<ol>
<li>是父级元素高度不固定，随着内容变化</li>
<li>父级元素高度固定</li>
</ol>
<h2 id="父级元素高度不固定"><a href="#父级元素高度不固定" class="headerlink" title="父级元素高度不固定"></a>父级元素高度不固定</h2><p>父级高度不固定的时，高度只能通过内部文本来撑开。这样，我们可以通过设置内填充（padding）的值来使文本看起来垂直居中，只需设置<code>padding-top</code>和<code>padding-bottom</code>的值相等。</p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">	这是多行文本垂直居中，</span><br><span class="line">	这是多行文本垂直居中，</span><br><span class="line">	这是多行文本垂直居中，</span><br><span class="line">	这是多行文本垂直居中。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">margin</span>: <span class="number">50px</span> auto;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">text-align</span>: center; <span class="comment">/*设置文本水平居中*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">50px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="父级元素高度固定"><a href="#父级元素高度固定" class="headerlink" title="父级元素高度固定"></a>父级元素高度固定</h2><p>在本文一开始就提到了<code>vertical-align</code>属性只对拥有 valign 特性的元素才生效，所以可以结合<code>display: table;</code>，使得 div 元素模拟 table 的属性。</p>
<p>具体操作为：设置父级div为<code>display: table;</code>，添加一个子 div 用于显示文本内容，并给该子 div 元素设置<code>display: table-cell;</code>和<code>vertical-align: middle;</code>属性。</p>
<p>具体代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">        这是固定高度多行文本垂直居中，</span><br><span class="line">        这是固定高度多行文本垂直居中，</span><br><span class="line">        这是固定高度多行文本垂直居中，</span><br><span class="line">		这是固定高度多行文本垂直居中。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#outer</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css"> 	<span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#middle</span>&#123; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>:table-cell; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">vertical-align</span>:middle;  </span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center; <span class="comment">/*设置文本水平居中*/</span>  </span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">100%</span>;   </span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="子div垂直居中"><a href="#子div垂直居中" class="headerlink" title="子div垂直居中"></a>子div垂直居中</h1><h2 id="1、根据子div具体大小设置偏移"><a href="#1、根据子div具体大小设置偏移" class="headerlink" title="1、根据子div具体大小设置偏移"></a>1、根据子div具体大小设置偏移</h2><p>如果子div固定大小，设定水平和垂直偏移父元素的50%，再根据实际长度将子元素向上和向左挪回一半大小</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">		子div(固定大小)垂直居中</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#13CDF4</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.middle</span>&#123; </span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#E41627</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">50%</span>; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、translate"><a href="#2、translate" class="headerlink" title="2、translate"></a>2、translate</h2><p>针对第一种方法中水平和垂直偏移父元素的50%后，不设置 margin 值，而是利用除css3中的 transform 属性设置 translate 的值，css代码部分改成如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">middle&#123; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#E41627</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">50%</span>; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">	-webkit-<span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方法需要注意transform是css3中的属性，使用时注意浏览器的兼容性，IE9之前的版本不支持。</p>
<h2 id="3、absolute"><a href="#3、absolute" class="headerlink" title="3、absolute"></a>3、absolute</h2><p>利用绝对定位实现子 div 大小不固定垂直居中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">		绝对布局absolute垂直居中</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#13CDF4</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.middle</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#E41627</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;   //子<span class="selector-tag">div</span>大小可随意设置</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">top</span>: <span class="number">0</span>;<span class="attribute">left</span>: <span class="number">0</span>;<span class="attribute">right</span>: <span class="number">0</span>;<span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该方法不兼容IE7、IE6</p>
<h2 id="4、vertical-align"><a href="#4、vertical-align" class="headerlink" title="4、vertical-align"></a>4、vertical-align</h2><p>利用<code>vertical-align</code>属性实现子div大小不固定垂直居中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">    	利用vertical-align属性实现子div大小不固定垂直居中</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#13CDF4</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table-cell; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.middle</span>&#123; </span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#E41627</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方法是将div转变成table-cell显示，然后通过<code>vertical-align: middle;</code>再设置其子元素垂直居中，这种方法和上面设置父级元素高度固定时多行文本居中的方法一样，所以这种方法也不能兼容IE7、IE6。</p>
<h2 id="5、利用display-flex"><a href="#5、利用display-flex" class="headerlink" title="5、利用display: flex"></a>5、利用display: flex</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">        利用display: flex实现子div大小不固定垂直居中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#13CDF4</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">justify-content</span>: center;<span class="comment">/*实现水平居中*/</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">align-items</span>:center; <span class="comment">/*实现垂直居中*/</span></span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.middle</span>&#123; </span></span><br><span class="line"><span class="language-css">	<span class="attribute">background-color</span>: <span class="number">#E41627</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这种方法只需要在父级div中加上这三句话就行，但是在IE中兼容性不好，IE9及以下IE浏览器版本都不支持。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上是笔者总结的一些常用到的垂直居中的布局方法，读者可以根据自己的需要选择合适的布局方式。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa中间件原理</title>
    <url>/2022/02/28/Koa%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h1><p>中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p>
<span id="more"></span>
<p>在 <code>Nodejs</code> 中，<strong>中间件</strong>主要是指封装 <strong>http</strong> 请求细节处理的方法。我们都知道在 <strong>http</strong> 请求中往往会涉及很多动作，如下:</p>
<ul>
<li>IP 筛选</li>
<li>查询字符串传递</li>
<li>请求体解析</li>
<li>cookie 信息处理</li>
<li>权限校验</li>
<li>日志记录</li>
<li>会话管理中间件(session)</li>
<li>gzip 压缩中间件(如 compress)</li>
<li>错误处理</li>
</ul>
<p>当然还有很多自定义的处理动作. 对于 <strong>Web</strong> 应用而言，我们并不希望了解每一个细节性的处理工作，而是希望能够把主要精力集中在业务的开发上，以达到提升开发效率的目的，所以引入了 <strong>Node 中间件</strong><br>来简化和封装这些基础逻辑处理细节.</p>
<p><strong>node 中间件</strong>本质上就是在进入具体的业务处理之前，先让<strong>特定过滤器</strong>处理。如下图所示:</p>
<p><img src="https://user-images.githubusercontent.com/33454514/156928218-c20afb06-df25-4dd1-b7d4-ff9a03a07084.png" alt="image"></p>
<p>我们目前看到的主流  <code>Nodejs</code> 框架，比如 <code>koa，express，egg</code> 等，都离不开中间件的设计概念，所以为了能让大家更深入的窥探  <code>Nodejs</code> 世界，我们就非常有比较研究中间件的实现原理。</p>
<h1 id="node-中间件核心原理实现"><a href="#node-中间件核心原理实现" class="headerlink" title="node 中间件核心原理实现"></a>node 中间件核心原理实现</h1><p>由上文介绍可知，中间件是从 http 请求开始到响应结束过程中的处理逻辑，通常需要对请求和响应进行处理。我们在实现 node<br>中间件模式时还需要考虑的一个问题就是多中间件共存的问题，我们要思考如何将多个中间件的执行自动化，不然在请求到响应的过程中只会执行最开始的中间件，所以我们基本的中间件形式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">middleware</span> = (<span class="params">req, res, next</span>) =&gt; &#123;  <span class="comment">// 请求处理逻辑 </span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>接下来我们先写个简单的案例来看看中间件是如何实现的.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义几个中间间函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">m1</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m1 run&#x27;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">m2</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m2 run&#x27;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">m3</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m3 run&#x27;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件集合const middlewares = [m1, m2, m3]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useApp</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;    <span class="comment">// 获取第一个中间件</span></span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">      <span class="title function_">middleware</span>(req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次请求流进入</span></span><br><span class="line"><span class="title function_">useApp</span>();</span><br></pre></td></tr></table></figure>

<p>由以上代码我们就不难发现 <strong>next</strong> 的作用了，也就是实现自动调用中间件链的关键参数. 打印结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m1 run</span><br><span class="line">m2 runm3</span><br><span class="line">run </span><br></pre></td></tr></table></figure>

<p>以上即实现了基本中间件的执行模式，但是我们还需要考虑异步的问题，如果中间件还依赖第三发模块或者 api 的支持，比如验证，识别等服务，我们需要在该异步中间件的回调里执行 next，才能保证正常的调用执行顺序，如下代码所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">m2</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/xxxxx&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>还有一种中间件场景，比如说日志中间件，请求监控中间件，它们会在业务处理前和处理后都会执行相关逻辑，这个时候就要求我们需要能对 <strong>next</strong> 函数进行二次处理，我们可以将 next 的返回值包装成 <strong>promise</strong><br>，使得其在业务处理完成之后通过 <strong>then</strong> 回调来继续处理中间件逻辑. 如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useApp</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;      <span class="comment">// 将返回值包装为Promise对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">middleware</span>(req, res, next));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>此时我们就能使用如下方式调用了:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">m1</span> = (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;m1 end&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上我们就实现了一个基本可以的中间件设计模式，当然我们也可以用 async 和 await 实现，写法会更优雅和简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">m1</span> = <span class="keyword">async</span> (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// something...</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">m2</span> = <span class="keyword">async</span> (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// something... </span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">m3</span> = <span class="keyword">async</span> (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// something... </span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [m1, m2, m3]</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useApp</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = middlewares.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">middleware</span>(req, res, next));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动中间件useApp() </span></span><br></pre></td></tr></table></figure>

<p>在 koa2 框架中，中间件的实现方式也是将 <code>next()</code> 方法返回值封装为 Promise 对象，实现了其提出的洋葱圈模型：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/156928188-db25c072-6697-49eb-a099-d940a69dd147.png" alt="image"></p>
<h1 id="koa-中间件实现方式"><a href="#koa-中间件实现方式" class="headerlink" title="koa 中间件实现方式"></a>koa 中间件实现方式</h1><p>koa2 框架的中间件实现原理很优雅，这里贴上源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">middleware</span>) &#123;  <span class="comment">// 提前判断中间件类型,防止后续错误</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware stack must be an array!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;    <span class="comment">// 中间件必须为函数类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware must be composed of functions!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;    <span class="comment">// 采用闭包将索引缓存,来实现调用计数</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">i</span>) &#123;      <span class="comment">// 防止next()方法重复调用  </span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) &#123;</span><br><span class="line">        fn = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;        <span class="comment">// 包装next()返回值为Promise对象  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;        <span class="comment">// 异常处理 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现一个自己的-koa-中间件"><a href="#实现一个自己的-koa-中间件" class="headerlink" title="实现一个自己的 koa 中间件"></a>实现一个自己的 koa 中间件</h1><p>在服务端中，我们经常需要对用户登录权限进行过滤，此时我们提供统一个中间件来处理用户权限：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据库操作</span></span><br><span class="line"><span class="keyword">const</span> token = db.<span class="title function_">user</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// router或者koa的中间件一定要用await处理next，否则将不能正常响应数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> t = ctx.<span class="property">request</span>.<span class="property">header</span>.<span class="property">authorization</span>;</span><br><span class="line">  <span class="keyword">let</span> uid = ctx.<span class="property">request</span>.<span class="property">header</span>[<span class="string">&#x27;x-requested-with&#x27;</span>];</span><br><span class="line">  <span class="keyword">let</span> uidArr = uid.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (uidArr.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    uid = uidArr.<span class="title function_">pop</span>().<span class="title function_">trim</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (token[uid] &amp;&amp; token[uid][<span class="number">1</span>] === t) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">403</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = &#123;</span><br><span class="line">      <span class="attr">state</span>: <span class="number">403</span>,</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;未登录或没有权限&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以上代码即实现用户登录态处理，如果用户在没有登录的情况下防问任何需要登录的接口，都将返回权限不足或则在请求库中让其重定向到登录页面</p>
]]></content>
      <categories>
        <category>Koa</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>Koa</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题指南</title>
    <url>/2021/09/22/LeetCode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>如何判断该使用回溯：感觉如果不穷举一下就没法知道答案。</p>
<p>一般回溯的问题有三种：</p>
<ol>
<li> Find a path to success 有没有解</li>
<li> Find all paths to success 求所有解</li>
<li> 求所有解的个数</li>
<li> 求所有解的具体信息</li>
<li> Find the best path to success 求最优解</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">新区域, res, path</span>):</span><br><span class="line">    <span class="keyword">if</span> 结束:<span class="comment"># 一般是最小值最大值</span></span><br><span class="line">        res.add(path) <span class="comment"># </span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 新区域:</span><br><span class="line">        <span class="keyword">if</span> 符合要求:</span><br><span class="line">            path.add(当前选择)</span><br><span class="line">            backtrack(新区域, res, path)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>


<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h3 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h3><ol>
<li> 定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；</li>
<li> 第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；</li>
<li>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；<br> 当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；</li>
<li>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求<br> 最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。</li>
<li> right 指针每次向右移动一步，开始探索新的区间。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意：<span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


<h3 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h3><ol>
<li> 当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</li>
<li> 什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</li>
<li> 当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</li>
<li> 我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># s为匹配串，t为模式串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slideWindow</span>(<span class="params">s, t</span>):</span><br><span class="line">    needs, window = collections.defaultdict(<span class="built_in">int</span>), collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 计录模式串中每个字符分别有多少个</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">        needs[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 记录窗口中满足模式串字符的个数</span></span><br><span class="line">    valid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="comment"># 进入窗口的字符</span></span><br><span class="line">        c = s[right]</span><br><span class="line">        <span class="comment"># 更新窗口内数据</span></span><br><span class="line">        do something</span><br><span class="line"></span><br><span class="line">        <span class="comment"># debug 位置</span></span><br><span class="line">        <span class="built_in">print</span>(left, right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 窗口收缩操作</span></span><br><span class="line">        <span class="keyword">while</span> left need to shrink:</span><br><span class="line">            d = s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新窗口内数据</span></span><br><span class="line">            do something</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 窗口右移</span></span><br><span class="line">        right += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>问题的本质就是让你在一幅「图」中找到从起点 <em>start</em> 到终点 <em>target</em> 的最近距离</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start, target</span>):</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    <span class="comment"># 记录是否经过该节点</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化第一个节点</span></span><br><span class="line">    queue.apped(start)</span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 从当前节点向四周扩散</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">            temp = queue.popleft()</span><br><span class="line">            <span class="comment"># 是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> temp == target:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="comment"># 添加相邻节点</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> temp.相邻节点:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.apped(node)</span><br><span class="line">                    visited.add(node)</span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySeaech</span>(<span class="params">nums</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> condition:</span><br><span class="line">        mid = lefg + (right -left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            do something</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = something</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = something</span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure>


<h1 id="背包问题："><a href="#背包问题：" class="headerlink" title="背包问题："></a>背包问题：</h1><p>定义 dp 数组的作用十分关键！！！</p>
<p>必须明确dp[i][j]，i，j，分别代表什么，并为dp数组正确初始化。</p>
<p>然后是定义状态转移方程，之后就可以愉快地套模板了~</p>
<h3 id="通用转移方程"><a href="#通用转移方程" class="headerlink" title="通用转移方程"></a>通用转移方程</h3><ol>
<li>最值问题:</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i] = <span class="built_in">max</span>/<span class="built_in">min</span>(dp[i], dp[i - nums] + <span class="number">1</span>) 或者 dp[i] = <span class="built_in">max</span>/<span class="built_in">min</span>(dp[i], dp[i - num] + num)</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>存在问题(bool)：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i] <span class="keyword">or</span> dp[i - num]</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>组合问题：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dp[i] += dp[i - num]</span><br></pre></td></tr></table></figure>


<h3 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bags</span>(<span class="params">nums, target</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 设定所需的初始状态</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = [<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                转移方程<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                转移方程<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h3 id="一维dp"><a href="#一维dp" class="headerlink" title="一维dp"></a>一维dp</h3><ol>
<li>如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num, target + <span class="number">1</span>):</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br></pre></td></tr></table></figure>


<p>整体代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bags</span>(<span class="params">nums, target</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定所需的初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            转移方程</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>


<h1 id="手撸LRU"><a href="#手撸LRU" class="headerlink" title="手撸LRU"></a>手撸LRU</h1><ol>
<li>新加入的节点放在链表末尾，<code>addNodeToLast(node)</code></li>
<li>若容量达到上限，去除最久未使用的数据，<code>removeHeadNode(head.next)</code></li>
<li>若数据新被访问过，比如被<code>get</code>了或被<code>put</code>了新值，把该节点挪到链表末尾，<code>moveNodeToLast(node)</code></li>
</ol>
<p>下图为lru的基本数据结构，用hashmap存储<code>&#123;value: node&#125;</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1431305/1628497262413-769ddb04-b2b2-4d59-95ad-2e79bcc8d57f.jpeg#height=256&id=LiL9J&originHeight=511&originWidth=997&originalType=binary&ratio=1&status=done&style=none&width=499"></p>
<p><code>put</code>操作的逻辑</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1431305/1628497265751-aa1e3cc8-aefa-49ef-914b-d4094dd429a9.jpeg#height=406&id=BFC0S&originHeight=811&originWidth=955&originalType=binary&ratio=1&status=done&style=none&width=478"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key=<span class="number">0</span>, val=<span class="number">0</span></span>):</span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;</span><br><span class="line">        self.head = TreeNode()</span><br><span class="line">        self.tail = TreeNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = self.head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_node</span>(<span class="params">self, node</span>):</span><br><span class="line">        node.pre.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.pre = node.pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, node</span>):</span><br><span class="line">        self.tail.pre.<span class="built_in">next</span> = node</span><br><span class="line">        node.pre = self.tail.pre</span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_node_to_last</span>(<span class="params">self, node</span>):</span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_node(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.hashmap[key]</span><br><span class="line">        self.move_node_to_last(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            node = self.hashmap[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_node_to_last(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.hashmap) == self.capacity:</span><br><span class="line">            self.hashmap.pop(self.head.<span class="built_in">next</span>.key)</span><br><span class="line">            self.remove_node(self.head.<span class="built_in">next</span>)</span><br><span class="line">        node = TreeNode(key, value)</span><br><span class="line">        self.add_node(node)</span><br><span class="line">        self.hashmap[key] = node</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs常见问题汇总</title>
    <url>/2022/02/24/Nodejs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="windows-和-mac-下设置-NODE-ENV-变量"><a href="#windows-和-mac-下设置-NODE-ENV-变量" class="headerlink" title="windows 和  mac 下设置 NODE_ENV 变量"></a>windows 和  mac 下设置 NODE_ENV 变量</h1><p>在前端项目中会根据不同的环境变量来处理不同的逻辑，在<code>NodeJS</code>中也一样，我们需要设置本地开发环境，测试环境，线上环境等，此时有一直设置环境变量的方案是在<code>package.json</code>中的<code>script</code>属性中设置，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;   </span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;export NODE_ENV=development &amp;&amp; nodemon -w src --exec \&quot;babel-node src\&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;babel src --out-dir dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;run-build&quot;</span>: <span class="string">&quot;node dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>start</code>指令中我们可以发现我们用<code>export NODE_ENV=development</code>来定义开发环境的环境变量，由于笔者采用的是<code>mac</code>电脑，所以可以用<code>export</code>来定义一个<code>node</code>环境变量。 但是在windows环境下开发项目时发现，执行<code>yarn start</code>后会报错，后面看错误信息才发现<code>windows</code>下不识别<code>export</code>命令。在<code>windows</code>hua短颈下可以使用<code>set</code>定义环境变量。所以对于<code>windows</code>用户，如果你使用了以上方法设置<code>NODE_ENV</code>，可以采用如下方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;set NODE_ENV=development &amp;&amp; nodemon -w src --exec \&quot;babel-node src\&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行-npm-install-发生-node-gyp-报错"><a href="#执行-npm-install-发生-node-gyp-报错" class="headerlink" title="执行 npm install 发生 node-gyp 报错"></a>执行 npm install 发生 node-gyp 报错</h1><p>在项目开发过程中有时候拉取新的<code>node</code>项目代码后执行<code>npm install</code>，会报如下错误：</p>
<p><img src="https://static001.geekbang.org/infoq/37/3706e8d2ca1325f2b0295f58ce49ed9a.png" alt="img"></p>
<p><code>node-gyp</code>就是在<code>node</code>环境中使用的生成不同平台不同编译器的项目文件，如果你遇到了相同的问题，可以采用如下方案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g node-gyp</span><br></pre></td></tr></table></figure>

<p>或者直接删除<code>package-lock.json</code>或<code>yarn.lock</code>，然后重新<code>yarn install</code>或者<code>npm install</code>即可。</p>
<p>如果还是失败，可以尝试先清除全局下的<code>npm cache</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure>

<p>再执行上述操作</p>
<h1 id="node-koa2-项目中删除已设置的-cookie"><a href="#node-koa2-项目中删除已设置的-cookie" class="headerlink" title="node + koa2 项目中删除已设置的 cookie"></a>node + koa2 项目中删除已设置的 cookie</h1><p>由于 HTTP 是无状态协议，所以需要 cookie 来区分用户之间的身份。 我们可以把 cookie 作为是一个由浏览器和服务器共同协作实现的规范。</p>
<p><code>cookie</code>的处理分为以下 3 步：</p>
<ol>
<li>服务器向客户端发送<code>cookie</code></li>
<li>浏览器将<code>cookie</code>保存（可以在后端设置 expires 或者 maxAge，以<code>session</code>形式存在）</li>
<li>每次浏览器都会将之前设置好的<code>cookie</code>发向服务器</li>
</ol>
<p>在开发<code>node</code>后台项目时我们经常涉及用户管理模块，这意味我们需要对用户进行<strong>登录态</strong>管理，在用户退出时能及时删除用户的<code>cookie</code>。<code>koa2</code>自带了处理<code>cookie</code>的方法，可以通过如下的方式设置<code>cookie</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(api.<span class="property">validVip</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">cookies</span>.<span class="title function_">set</span>(<span class="string">&#x27;vid&#x27;</span>，<span class="string">&#x27;xuxiaoxi&#x27;</span>，&#123; <span class="attr">maxAge</span>: <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码中设置了一个有效期为 1 天的<code>cookie</code>，那如果业务有变动，需要在有效期内清空此<code>cookie</code>，我们该如何处理呢? </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="property">cookies</span>.<span class="title function_">set</span>(<span class="string">&#x27;vid&#x27;</span>，<span class="string">&#x27;&#x27;</span>，&#123; <span class="attr">maxAge</span>: <span class="number">0</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>此时客户端的<code>cookie</code>将在下次请求时自动失效。</p>
<h1 id="socket-io-与-koa-配合使用"><a href="#socket-io-与-koa-配合使用" class="headerlink" title="socket.io 与 koa 配合使用"></a>socket.io 与 koa 配合使用</h1><p>我们都知道完整的<code>socket.io</code>通信由两部分组成:</p>
<ol>
<li>与 <strong>NodeJS HTTP</strong> 服务器集成（或安装在其上）的 <strong>socket.io</strong></li>
<li>在浏览器端加载的客户端库 <strong>socket.io-client</strong></li>
</ol>
<p>如果我们直接使用<code>koa</code>或者<code>egg</code>，我们需要将它们内部集成的<code>http</code>和<code>socket.io</code>做兼容，此时我们可以这样处理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> koa <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(app.<span class="title function_">callback</span>());</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的业务处理</span></span><br><span class="line"><span class="comment">// io</span></span><br><span class="line">io.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a user connected&#x27;</span>);</span><br><span class="line">    socket.<span class="title function_">on</span>(<span class="string">&#x27;doc load&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doc load&#x27;</span>, msg);</span><br><span class="line">        io.<span class="title function_">emit</span>(<span class="string">&#x27;getData&#x27;</span>, users);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过以上的方式就可以正常的将<code>koa</code>和<code>socket.io</code> 做兼容. 后面我们就可以正常的开发<code>IM</code>应用啦~</p>
<h1 id="由于-NodeJS-第三方模块依赖特定-node-版本导致报错"><a href="#由于-NodeJS-第三方模块依赖特定-node-版本导致报错" class="headerlink" title="由于 NodeJS 第三方模块依赖特定 node 版本导致报错"></a>由于 NodeJS 第三方模块依赖特定 node 版本导致报错</h1><p>这个情况笔者之前也遇到过，主要原因是第三方没有和<code>node</code>版本做到很好的向后兼容。此时解决方案就是更新此第三方包到最新版本，或者使用<code>node</code>包管理工具<code>nvm</code> 切换到适配的<code>node</code>版本，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 更新最新的包</span><br><span class="line">npm i xxx@latest</span><br><span class="line"></span><br><span class="line">// 使用包管理工具</span><br><span class="line">npm i -g nvm</span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 可以很方便的管理<code>node</code>版本</p>
<h1 id="NodeJS创建定时任务"><a href="#NodeJS创建定时任务" class="headerlink" title="NodeJS创建定时任务"></a>NodeJS创建定时任务</h1><p>定时任务在后端开发中是很常见的功能之一，其本质是<strong>根据时间规则，系统在后台自动执行相应的任务</strong>. 在<code>java</code>，<code>PHP</code> 等后台语言中有很丰富的定时任务的支持，对于<code>NodeJS</code> 这个兴起之秀来说，虽然没有那么成熟的生态，但是仍然有定时任务的模块，比如<code>node-schedule</code>.</p>
<blockquote>
<p><strong>Node Schedule</strong> 是用于 Node.js 的灵活的 cron 类和非 cron 类作业调度程序。它允许我们使用可选的重复规则来安排作业（任意函数）在特定日期执行。它在任何给定时间仅使用一个计时器（而不是每秒钟/分钟重新评估即将到来的作业）。</p>
</blockquote>
<p>一个很实用的场景是我们想在每年的双十一或者双十二让<code>node</code>程序自动抓取某电商的“商品羊毛”，并推送到自己的邮箱，此时我们就可以用<code>Node Schedule</code>来开启一个定时任务来执行我们的业务操作，笔者的很多<code>node</code>应用都采用了类似的模式.感兴趣可以互相交流一下</p>
<p>那什么是<code>cron</code>风格的 Scheduling 呢? 其<code>github</code>上给出了一个简单的介绍：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/156929120-6fbc9043-c9b6-4962-a2e5-d19d15b6bc8c.png" alt="image"></p>
<p>所以我们可以像如下方式这样来写一个定时任务:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> schedule = <span class="built_in">require</span>(<span class="string">&#x27;node-schedule&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> testJob = schedule.<span class="title function_">scheduleJob</span>(<span class="string">&#x27;22 * * * *&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;将在未来的每个时刻的22分时执行此代码&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="在-NodeJS-项目中使用-ES6-之后的语法"><a href="#在-NodeJS-项目中使用-ES6-之后的语法" class="headerlink" title="在 NodeJS 项目中使用 ES6 之后的语法"></a>在 NodeJS 项目中使用 ES6 之后的语法</h1><p>我们都知道现在<code>NodeJS</code>版本已经到 16.0+版本了，对最新的 ES 语法支持的也足够好，但是目前仍然有一些语法不支持，比如<code>import</code>，<code>export</code>，<code>@decorator</code>等。此时我们要在<code>node</code>项目中使用这些新特性，可以采用<code>babel</code>来解决上述问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [ </span><br><span class="line">        [    </span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="string">&quot;targets&quot;</span>: &#123; </span><br><span class="line">                    <span class="string">&quot;node&quot;</span>: <span class="string">&quot;current&quot;</span> </span><br><span class="line">                &#125;      </span><br><span class="line">            &#125;   </span><br><span class="line">        ] </span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>,</span><br><span class="line">            &#123; <span class="string">&quot;legacy&quot;</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>,</span><br><span class="line">            &#123; <span class="string">&quot;loose&quot;</span> : <span class="literal">true</span> &#125;</span><br><span class="line">        ]  </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们只需要在项目根目录里新建并写入如上文件，并安装<code>babel</code>对应的模块即可，如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @babel/cli @babel/core @babel/node @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>此时就可以使用这些新语法特性了</p>
<h1 id="NodeJS中优雅的处理-json-文件以及提高-json-读写性能"><a href="#NodeJS中优雅的处理-json-文件以及提高-json-读写性能" class="headerlink" title="NodeJS中优雅的处理 json 文件以及提高 json 读写性能"></a>NodeJS中优雅的处理 json 文件以及提高 json 读写性能</h1><p>对于<code>NodeJS</code>优化方面其实有很多要聊的，这里主要来说说<code>json</code>相关的优化方案.。主要从两个方面来优化：</p>
<ol>
<li><code>json</code>文件的读写性能，此时我们可以采用<code>fast-json-stringify</code> 来大大提高<code>json</code>的读写速度，其本质是提供了一套<code>json-schema</code>约束，让<code>json</code>结构更加有序，从而提高<code>json</code>的读取查询速度：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fastJson = <span class="built_in">require</span>(<span class="string">&#x27;fast-json-stringify&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringify = <span class="title function_">fastJson</span>(&#123;  </span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    <span class="attr">properties</span>: &#123;   </span><br><span class="line">        <span class="attr">firstName</span>: &#123;  </span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">lastName</span>: &#123; </span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">age</span>: &#123; </span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;Age in years&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;integer&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">reg</span>: &#123; </span><br><span class="line">        	<span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>另一方面，我们在<code>node</code> 端操作 json，如果用原生的写法会非常麻烦，此时我们最好自己对 json 读取进行封装来提高代码的简约性，或者我们直接使用第三方库<code>jsonfile</code> 来轻松读写<code>json</code>文件：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">&#x27;jsonfile&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">&#x27;test.json&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> jsonData = jsonFile.<span class="title function_">readFileSync</span>(fileName);</span><br></pre></td></tr></table></figure>

<h1 id="NodeJS读取大文件报错"><a href="#NodeJS读取大文件报错" class="headerlink" title="NodeJS读取大文件报错"></a>NodeJS读取大文件报错</h1><p>在<code>NodeJS</code>中 我们可以使用两种方式来读写文件，如下:</p>
<ol>
<li><strong>fs.readFile()</strong> 一次性将文件读取进内存中，如果文件过大会导致<code>node</code>内存不够而报错</li>
<li><strong>fs.createReadStream()</strong> 以文件流的方式读取，此时可以不用担心文件的大小</li>
</ol>
<p>由以上介绍可知如果我们要读取的文件可能会很大(比如视频等大文件)，我们一开始就要使用 **fs.createReadStream()**，其实如果我们需要对文件进行解析，比如要对简历等文件进行逐行解析提取关键语料，我们可以使用<code>node</code>的<code>readline</code>模块，此时我们就可以对文件进行逐行读取并解析，如下案例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> readlineTask = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: fs.<span class="title function_">createReadStream</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./lib&#x27;</span>)) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readlineTask.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123; </span><br><span class="line">    <span class="comment">// 读取每一行数据</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readlineTask.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="comment">//文件读取结束的逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="NodeJS-开启-gzip-优化网站性能"><a href="#NodeJS-开启-gzip-优化网站性能" class="headerlink" title="NodeJS 开启 gzip 优化网站性能"></a>NodeJS 开启 gzip 优化网站性能</h1><p>对于<code>NodeJS</code>开启<code>gzip</code> 的操作也属于 node 性能优化的一部分，经过这样的处理可以让网站加载更快。</p>
<p>可以使用<code>koa</code>的<code>koa-compress</code>中间件来实现<code>gzip</code> 功能。 具体实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> koa <span class="keyword">from</span> <span class="string">&#x27;koa&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> compress <span class="keyword">from</span> <span class="string">&#x27;koa-compress&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启gzip</span></span><br><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">threshold</span>: <span class="number">2048</span> &#125;;</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">compress</span>(options));</span><br></pre></td></tr></table></figure>

<p>当然<code>koa-compress</code>还有很多自定义的配置项，读者可以自行阅读官方文档</p>
<h1 id="windows-和-linux-系统下路径分隔符不一致"><a href="#windows-和-linux-系统下路径分隔符不一致" class="headerlink" title="windows 和 linux 系统下路径分隔符不一致"></a>windows 和 linux 系统下路径分隔符不一致</h1><p>这个问题也是系统之间的差异导致的，也是需要考虑的问题，我们都知道在<code>linux</code>系统下路径的分隔符为<code>/</code>，比如<code>lib/src/pages</code>，但是在<code>windows</code>下解析的可能就是<code>lib\\src\\pages</code>这样的路径，此时我们需要做适配，不然我们部署到不同系统上报错是必然的，所以我们需要全局配置路径通配符，笔者的解决方案如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="keyword">from</span> <span class="string">&#x27;os&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _$ = (os.<span class="title function_">platform</span>().<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;win32&#x27;</span>) ? <span class="string">&#x27;\\&#x27;</span> : <span class="string">&#x27;/&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>此时涉及到具体路径的地方我们用<code>_$</code> 代替即可，以上代码我们用到了<code>node</code>的<code>os</code>模块，感兴趣的可以研究一下，我们可以用<code>os</code>模块处理很多有意思的因为系统差异导致的问题</p>
<h1 id="NodeJS如何实现父子进程通信"><a href="#NodeJS如何实现父子进程通信" class="headerlink" title="NodeJS如何实现父子进程通信"></a>NodeJS如何实现父子进程通信</h1><p>由于<code>NodeJS</code>是单线程的，但是有时候我们需要支持处理多个进程的业务，目前<code>NodeJS</code>可以通过使用<code>child_process</code>父子进程的模式来模拟多进程：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/156929152-89ff27b8-27b0-47e0-85d1-27ad3e06e42f.png" alt="image"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computedTotal</span>(<span class="params">arr, cb</span>) &#123;   </span><br><span class="line">    <span class="comment">// 耗时计算任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与主进程通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听主进程信号</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="title function_">computedTotal</span>(bigDataArr, <span class="function">(<span class="params">flag</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 向主进程发送完成信号  </span></span><br><span class="line">        process.<span class="title function_">send</span>(flag);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span>(ctx.<span class="property">url</span> === <span class="string">&#x27;/fetch&#x27;</span>) &#123;  </span><br><span class="line">        <span class="keyword">const</span> data = ctx.<span class="property">request</span>.<span class="property">body</span>;    </span><br><span class="line">        <span class="comment">// 通知子进程开始执行任务,并传入数据</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">createPromisefork</span>(<span class="string">&#x27;./child.js&#x27;</span>, data); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 创建异步线程  </span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createPromisefork</span>(<span class="params">childUrl, data</span>) &#123; </span><br><span class="line">        <span class="comment">// 加载子进程   </span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">fork</span>(childUrl);</span><br><span class="line">        <span class="comment">// 通知子进程开始work </span></span><br><span class="line">        data &amp;&amp; res.<span class="title function_">send</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">reslove</span> =&gt;</span> &#123;   </span><br><span class="line">            res.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">f</span> =&gt;</span> &#123;   </span><br><span class="line">                   <span class="title function_">reslove</span>(f);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="node-端实现图片编辑-压缩"><a href="#node-端实现图片编辑-压缩" class="headerlink" title="node 端实现图片编辑 / 压缩"></a>node 端实现图片编辑 / 压缩</h1><p>图片编辑压缩在很多场景中用前端的技术实现比较常见，其实在<code>node</code>端也有很多需要处理的图片需要，毕竟客户端处理的质量不好控制，此时我们可以采用<code>node-images</code>，他是一款<code>node</code> 端轻量级跨平台图像编解码库，其主要特性如下：</p>
<ol>
<li><strong>轻量级</strong>：无需安装任何图像处理库。</li>
<li><strong>跨平台</strong>：Windows 下发布了编译好的.node 文件,下载就能用。</li>
<li><strong>使用简单</strong>：jQuery 风格的 API，简单可依赖</li>
</ol>
<p>我们可以使用它来裁剪，压缩图片，基本使用如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="built_in">require</span>(<span class="string">&quot;images&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">images</span>(<span class="string">&quot;input.jpg&quot;</span>)  <span class="comment">// 加载图像文件</span></span><br><span class="line">    .<span class="title function_">size</span>(<span class="number">400</span>)  <span class="comment">// 等比缩放图像到400像素宽</span></span><br><span class="line">    .<span class="title function_">draw</span>(<span class="title function_">images</span>(<span class="string">&quot;logo.png&quot;</span>), <span class="number">10</span>, <span class="number">10</span>)   <span class="comment">// 在(10, 10)处绘制Logo</span></span><br><span class="line">    .<span class="title function_">save</span>(<span class="string">&quot;output.jpg&quot;</span>, &#123;quality : <span class="number">50</span>&#125;);  <span class="comment">// 保存图片到文件,图片质量为50</span></span><br></pre></td></tr></table></figure>

<h1 id="node-应用负载均衡和进程管理"><a href="#node-应用负载均衡和进程管理" class="headerlink" title="node 应用负载均衡和进程管理"></a>node 应用负载均衡和进程管理</h1><p>解决此问题最好的方式就是采用<code>pm2</code> 或者<code>forever</code>，其提供了强大的<code>node</code>进程管理，负载均衡的能力，并提供了一定程度的应用监控，建议在线上环境使用<code>pm2</code> 来管理<code>node</code>应用。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文系列（四）—— RabbitMQ</title>
    <url>/2021/09/21/RabbitMQ/</url>
    <content><![CDATA[<p>这是八股文系列的第四篇文章，主要是关于RabbitMQ的面试常问问题。</p>
<p>本文仅仅列举问题的部分常见解答，详细回答需结合官方文档和日常工作使用经验。😉</p>
<span id="more"></span>

<h2 id="1-RabbitMQ是什么？"><a href="#1-RabbitMQ是什么？" class="headerlink" title="1.RabbitMQ是什么？"></a>1.RabbitMQ是什么？</h2><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。<br>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件</p>
<h2 id="2-RabbitMQ特点"><a href="#2-RabbitMQ特点" class="headerlink" title="2.RabbitMQ特点?"></a>2.RabbitMQ特点?</h2><p>可靠性: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。<br>灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。<br>扩展性: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。<br>高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。<br>多种协议: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。<br>多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。<br>管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。<br>令插件机制 : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p>
<h2 id="3-AMQP是什么"><a href="#3-AMQP是什么" class="headerlink" title="3.AMQP是什么?"></a>3.AMQP是什么?</h2><p>RabbitMQ就是 AMQP 协议的 Erlang 的实现(当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。<br>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>
<h2 id="4-AMQP协议3层？"><a href="#4-AMQP协议3层？" class="headerlink" title="4.AMQP协议3层？"></a>4.AMQP协议3层？</h2><p>Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。<br>Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。<br>TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</p>
<h2 id="5-AMQP模型的几大组件？"><a href="#5-AMQP模型的几大组件？" class="headerlink" title="5.AMQP模型的几大组件？"></a>5.AMQP模型的几大组件？</h2><ul>
<li>交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。</li>
<li>队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。</li>
<li>绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>
</ul>
<h2 id="6-说说生产者Producer和消费者Consumer"><a href="#6-说说生产者Producer和消费者Consumer" class="headerlink" title="6.说说生产者Producer和消费者Consumer?"></a>6.说说生产者Producer和消费者Consumer?</h2><p>生产者</p>
<ul>
<li>消息生产者，就是投递消息的一方。</li>
<li>消息一般包含两个部分：消息体（payload)和标签(Label)。</li>
</ul>
<p>消费者</p>
<ul>
<li>消费消息，也就是接收消息的一方。</li>
<li>消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>
</ul>
<h2 id="7-为什么需要消息队列？"><a href="#7-为什么需要消息队列？" class="headerlink" title="7.为什么需要消息队列？"></a>7.为什么需要消息队列？</h2><p>从本质上来说是因为互联网的快速发展，业务不断扩张，促使技术架构需要不断的演进。<br>从以前的单体架构到现在的微服务架构，成百上千的服务之间相互调用和依赖。从互联网初期一个服务器上有 100 个在线用户已经很了不得，到现在坐拥10亿日活的微信。此时，我们需要有一个「工具」来解耦服务之间的关系、控制资源合理合时的使用以及缓冲流量洪峰等等。因此，消息队列就应运而生了。<br>它常用来实现：异步处理、服务解耦、流量控制（削峰）。</p>
<h2 id="8-说说Broker服务节点、Queue队列、Exchange交换器？"><a href="#8-说说Broker服务节点、Queue队列、Exchange交换器？" class="headerlink" title="8.说说Broker服务节点、Queue队列、Exchange交换器？"></a>8.说说Broker服务节点、Queue队列、Exchange交换器？</h2><ul>
<li>Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。</li>
<li>Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>
<li>Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>
</ul>
<h2 id="9-消息队列有什么优缺点"><a href="#9-消息队列有什么优缺点" class="headerlink" title="9.消息队列有什么优缺点"></a>9.消息队列有什么优缺点</h2><p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：</p>
<ul>
<li>系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩 溃，你不就完了？</li>
<li>系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？</li>
<li>怎么保证消息传递的顺序性？问题一大堆。</li>
<li>一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致 了。</li>
</ul>
<h2 id="10-如何保证消息的可靠性？"><a href="#10-如何保证消息的可靠性？" class="headerlink" title="10.如何保证消息的可靠性？"></a>10.如何保证消息的可靠性？</h2><p>消息到MQ的过程中搞丢，MQ自己搞丢，MQ到消费过程中搞丢。<br>生产者到RabbitMQ：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。<br>RabbitMQ自身：持久化、集群、普通模式、镜像模式。<br>RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。</p>
<h2 id="11-什么是RoutingKey路由键？"><a href="#11-什么是RoutingKey路由键？" class="headerlink" title="11.什么是RoutingKey路由键？"></a>11.什么是RoutingKey路由键？</h2><p>生产者将消息发送给交换器的时候，会指定一个RoutingKey,用来指定这个消息的路由规则，这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。</p>
<h2 id="12-Binding绑定？"><a href="#12-Binding绑定？" class="headerlink" title="12.Binding绑定？"></a>12.Binding绑定？</h2><p>通过绑定将交换器和队列关联起来，一般会指定一个BindingKey,这样RabbitMq就知道如何正确路由消息到队列了。</p>
<h2 id="13-交换器4种类型？"><a href="#13-交换器4种类型？" class="headerlink" title="13.交换器4种类型？"></a>13.交换器4种类型？</h2><p>主要有以下4种。</p>
<ul>
<li>fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li>
<li>direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。</li>
<li>topic:</li>
<li>匹配规则： <ul>
<li>RoutingKey：为一个 点号’.’: 分隔的字符串。比如: java.xiaoka.show </li>
<li>BindingKey：和RoutingKey一样也是点号“.“分隔的字符串。BindingKey可使用 * 和 # 用于做模糊匹配，*匹配一个单词，#匹配多个或者0个 </li>
<li>headers：不依赖路由键匹配规则路由消息。是根据发送消息内容中的headers属性进行匹配。性能差，基本用不到。</li>
</ul>
</li>
</ul>
<h2 id="14-生产者消息运转？"><a href="#14-生产者消息运转？" class="headerlink" title="14.生产者消息运转？"></a>14.生产者消息运转？</h2><ol>
<li>Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。</li>
<li>Producer声明一个交换器并设置好相关属性。</li>
<li>Producer声明一个队列并设置好相关属性。</li>
<li>Producer通过路由键将交换器和队列绑定起来。</li>
<li>Producer发送消息到Broker,其中包含路由键、交换器等信息。</li>
<li>相应的交换器根据接收到的路由键查找匹配的队列。</li>
<li>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</li>
<li>关闭信道。</li>
<li>管理连接。</li>
</ol>
<h2 id="15-消费者接收消息过程？"><a href="#15-消费者接收消息过程？" class="headerlink" title="15.消费者接收消息过程？"></a>15.消费者接收消息过程？</h2><ol>
<li>Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。</li>
<li>向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。</li>
<li>等待Broker回应并投递相应队列中的消息，接收消息。</li>
<li>消费者确认收到的消息,ack。</li>
<li>RabbitMq从队列中删除已经确定的消息。</li>
<li>关闭信道。</li>
<li>关闭连接。</li>
</ol>
<h2 id="16-交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"><a href="#16-交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？" class="headerlink" title="16.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？"></a>16.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？</h2><ul>
<li>mandatory：true 返回消息给生产者。</li>
<li>mandatory: false 直接丢弃。</li>
</ul>
<h2 id="17-死信队列？"><a href="#17-死信队列？" class="headerlink" title="17.死信队列？"></a>17.死信队列？</h2><p>DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>
<h2 id="18-导致的死信的几种原因？"><a href="#18-导致的死信的几种原因？" class="headerlink" title="18.导致的死信的几种原因？"></a>18.导致的死信的几种原因？</h2><ul>
<li>消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。</li>
<li>消息TTL过期。</li>
<li>队列满了，无法再添加。</li>
</ul>
<h2 id="19-延迟队列？"><a href="#19-延迟队列？" class="headerlink" title="19.延迟队列？"></a>19.延迟队列？</h2><p>存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>
<h2 id="20-优先级队列？"><a href="#20-优先级队列？" class="headerlink" title="20.优先级队列？"></a>20.优先级队列？</h2><ul>
<li>优先级高的队列会先被消费。</li>
<li>可以通过x-max-priority参数来实现。</li>
<li>当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。</li>
</ul>
<h2 id="21-事务机制？"><a href="#21-事务机制？" class="headerlink" title="21.事务机制？"></a>21.事务机制？</h2><p>RabbitMQ 客户端中与事务机制相关的方法有三个:</p>
<ol>
<li>channel.txSelect 用于将当前的信道设置成事务模式。</li>
<li>channel . txCommit 用于提交事务 。</li>
<li>channel . txRollback 用于事务回滚,如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常,通过txRollback来回滚。</li>
</ol>
<h2 id="22-发送确认机制？"><a href="#22-发送确认机制？" class="headerlink" title="22.发送确认机制？"></a>22.发送确认机制？</h2><p>生产者把信道设置为confirm确认模式,设置后，所有再改信道发布的消息都会被指定一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack)给生产者（包含消息的唯一ID)，这样生产者就知道消息到达对应的目的地了。</p>
<h2 id="23-消费者获取消息的方式？"><a href="#23-消费者获取消息的方式？" class="headerlink" title="23.消费者获取消息的方式？"></a>23.消费者获取消息的方式？</h2><ul>
<li>推</li>
<li>拉</li>
</ul>
<h2 id="24-消费者某些原因无法处理当前接受的消息如何来拒绝？"><a href="#24-消费者某些原因无法处理当前接受的消息如何来拒绝？" class="headerlink" title="24.消费者某些原因无法处理当前接受的消息如何来拒绝？"></a>24.消费者某些原因无法处理当前接受的消息如何来拒绝？</h2><p>channel .basicNack channel .basicReject</p>
<h2 id="25-消息传输保证层级？"><a href="#25-消息传输保证层级？" class="headerlink" title="25.消息传输保证层级？"></a>25.消息传输保证层级？</h2><p>At most once:最多一次。消息可能会丢失，但不会重复传输。<br>At least once：最少一次。消息绝不会丢失，但可能会重复传输。<br>Exactly once: 恰好一次，每条消息肯定仅传输一次。</p>
<h2 id="26-了解Virtual-Host吗"><a href="#26-了解Virtual-Host吗" class="headerlink" title="26.了解Virtual Host吗?"></a>26.了解Virtual Host吗?</h2><p>每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫虚拟主机(virtual host)，简称vhost。<br>默认为“/”。</p>
<h2 id="27-集群中的节点类型？"><a href="#27-集群中的节点类型？" class="headerlink" title="27.集群中的节点类型？"></a>27.集群中的节点类型？</h2><ol>
<li>内存节点：ram,将变更写入内存。</li>
<li>磁盘节点：disc,磁盘写入操作。</li>
<li>RabbitMQ要求最少有一个磁盘节点。</li>
</ol>
<h2 id="28-队列结构？"><a href="#28-队列结构？" class="headerlink" title="28.队列结构？"></a>28.队列结构？</h2><p>通常由以下两部分组成：</p>
<ol>
<li>rabbit_amqqueue_process:负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等。</li>
<li>backing_queue:是消息存储的具体形式和引擎，并向 rabbit amqqueue process提供相关的接口以供调用。</li>
</ol>
<h2 id="29-RabbitMQ中消息可能有的几种状态"><a href="#29-RabbitMQ中消息可能有的几种状态" class="headerlink" title="29.RabbitMQ中消息可能有的几种状态?"></a>29.RabbitMQ中消息可能有的几种状态?</h2><ol>
<li>alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。</li>
<li>beta: 消息内容保存在磁盘中，消息索引保存在内存中。</li>
<li>gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。</li>
<li>delta: 消息内容和索引都在磁盘中 。</li>
</ol>
<h2 id="30-在何种场景下使用了消息中间件？"><a href="#30-在何种场景下使用了消息中间件？" class="headerlink" title="30.在何种场景下使用了消息中间件？"></a>30.在何种场景下使用了消息中间件？</h2><ul>
<li>接口之间耦合比较严重</li>
<li>面对大流量并发时，容易被冲垮</li>
<li>存在性能问题</li>
</ul>
<h2 id="31-生产者如何将消息可靠投递到MQ？"><a href="#31-生产者如何将消息可靠投递到MQ？" class="headerlink" title="31.生产者如何将消息可靠投递到MQ？"></a>31.生产者如何将消息可靠投递到MQ？</h2><ol>
<li>Client发送消息给MQ</li>
<li>MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；</li>
<li>Client收到Ack消息后，认为消息已经投递成功。</li>
</ol>
<h2 id="32-MQ如何将消息可靠投递到消费者？"><a href="#32-MQ如何将消息可靠投递到消费者？" class="headerlink" title="32 . MQ如何将消息可靠投递到消费者？"></a>32 . MQ如何将消息可靠投递到消费者？</h2><ol>
<li>MQ将消息push给Client（或Client来pull消息）</li>
<li>Client得到消息并做完业务逻辑</li>
<li>Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；</li>
<li>MQ将已消费的消息删除</li>
</ol>
<h2 id="33-如何保证RabbitMQ消息队列的高可用"><a href="#33-如何保证RabbitMQ消息队列的高可用" class="headerlink" title="33.如何保证RabbitMQ消息队列的高可用?"></a>33.如何保证RabbitMQ消息队列的高可用?</h2><p>RabbitMQ 有三种模式：单机模式，普通集群模式，镜像集群模式。</p>
<ol>
<li>单机模式：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式</li>
<li>普通集群模式：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。</li>
<li>镜像集群模式：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</li>
</ol>
<h2 id="34-如何快速处理挤压过多的消息？"><a href="#34-如何快速处理挤压过多的消息？" class="headerlink" title="34.如何快速处理挤压过多的消息？"></a>34.如何快速处理挤压过多的消息？</h2><p>情景：消费者挂掉后再重启，这时会有很多已经挤压了的消息在MQ中，所以需要快速的处理之前已经挤压了的消息。<br>解决方案：可以将原由的消费者进行修改，不再直接对数据库进行操作，只对MQ的数据进行并将处理得到的数据再发给新的partition（可以创建很多来进行过度），然后再由很多消费者进行同时的消费，并写入数据库。这是处理速度就会很快。因为第一次的消费者处理之后并不用写入数据库就可以给MQ反馈已经消费了；后续的消费者继续处理需要消费的数据并不会影响之前的消费者处理的速度。</p>
<h2 id="35-如果消息队列满了怎么处理？"><a href="#35-如果消息队列满了怎么处理？" class="headerlink" title="35.如果消息队列满了怎么处理？"></a>35.如果消息队列满了怎么处理？</h2><p>类似上述问题：修改消费者消费方式（不直接进行消费，转发给另外的MQ），然后再由其他消费者进行消费。</p>
<h2 id="36-如果让你开发消息队列中间件，如何来设计？"><a href="#36-如果让你开发消息队列中间件，如何来设计？" class="headerlink" title="36.如果让你开发消息队列中间件，如何来设计？"></a>36.如果让你开发消息队列中间件，如何来设计？</h2><ol>
<li>考虑mq的伸缩性，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，这样就可以存放更多数据，提供更高的吞吐量了。</li>
<li>考虑mq数据要不要持久化？需要写入磁盘，这样才能保证挂了之后不会造成数据的丢失。写入时怎么进行写入磁盘？顺序写入，这样既保证了消息的顺序性，还减少了寻址的开销，达到提高性能的目的。</li>
<li>考虑mq的可用性？参考kafka的高可用的保障机制。多副本–》leader&amp;follwer–》broker挂了重新选举leader即可。</li>
</ol>
]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>rabbitmq</tag>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 命令之 Reset 与 Revert</title>
    <url>/2022/03/18/git%20%E5%91%BD%E4%BB%A4%E4%B9%8B%20reset%20%E4%B8%8E%20revert/</url>
    <content><![CDATA[<h1 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h1><p>git reset 命令可以将当前的<code>HEAD</code>重置到特定的状态。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先要搞清楚下面几个概念：</p>
<ul>
<li>HEAD：指向当前分支当前版本的游标</li>
<li>Index：暂存区，当你修改了你的 git 仓库里的一个文件时，这些变化一开始是 <strong>unstaged</strong> 状态，为了提交这些修改，你需要使用<code>git add</code>把它加入到 index，使它成为 <strong>staged</strong> 状态。当提交一个 commit 时，index 里面的修改被提交</li>
<li>working tree：当前的工作目录</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>git reset</code>的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>

<p> git reset 会将当前分支的 HEAD 指向给定的版本，并根据模式的不同决定是否修改 index 和 working tree<br>常用的<mode>有三种模式：<code>--soft</code>, <code>--mixed</code>, <code>--hard</code>，没有指定 <mode> 默认是<code>--mixed</code>模式</p>
<h2 id="soft"><a href="#soft" class="headerlink" title="soft"></a>soft</h2><p>使用<code>--soft</code>参数将会仅仅重置 HEAD 到制定的版本，不会修改 index 和 working tree。例如当前分支现在有三次提交，执行<code>git reset --soft HEAD~</code>之后，查看git log：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/160063514-924585e2-ff73-4d26-a7d3-21202d24a0bd.png" alt="image"></p>
<p>而本地文件的内容并没有发生变化，而index中仍然有最近一次提交的修改，这时执行git status会显示这些修改已经在再暂存区中了，无需再一次执行git add</p>
<p><img src="https://user-images.githubusercontent.com/33454514/160063524-adfbb0b1-3bf0-4276-8af2-ac9e8eb71ad9.png" alt="image"></p>
<h2 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h2><p>使用<code>--mixed</code>参数与<code>--soft</code>的不同之处在于，**–mixed** 修改了 <strong>index</strong>，使其与第二个版本匹配。index 中给定 commit 之后的修改被<code>unstaged</code>。</p>
<p><img src="https://user-images.githubusercontent.com/33454514/160063677-34caf47f-e0d8-453f-9e60-399bf17f848b.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/160063683-48b2685d-524f-47f2-8768-025792865840.png" alt="image"></p>
<p> 如果现在执行git commit 将不会发生任何事，因为暂存区中没有修改，在提交之前需要再次执行git add</p>
<h2 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h2><p>使用<code>--hard</code>同时也会修改 working tree，也就是当前的工作目录，如果我们执行<code>git reset --hard HEAD~</code>，那么最后一次提交的修改，包括本地文件的修改都会被清除，彻底还原到上一次提交的状态且无法找回。所以在执行<code>reset --hard</code>之前一定要小心！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>soft：重置 HEAD 到指定版本，影响 working tree</li>
<li>hard：会清除本地的修改文件，且无法找回</li>
<li>mixed：修改 index，需要重新执行 git add</li>
</ul>
<h1 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h1><p>使用<code>git revert</code>也能起到回退版本的作用，不同之处在于：</p>
<ul>
<li><code>git revert &lt;commit&gt;</code>会回退到 <commit> 之前的那次提交。比如：<code>git revert HEAD~3</code>会回退到最近的第4个提交的状态，而不是第3个</li>
<li><code>git revert</code>会产生一个新的commit，将这次回退作为一次修改记录提交，这样的好处是不修改历史提交记录</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/33454514/160064129-9af07499-5ddd-4f25-88e0-a3fc127a7ded.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/160064132-faf553f3-d344-4aab-801c-97c37fdb2e0a.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/160064136-d83d597a-9c75-4479-9665-d6f64c056ee8.png" alt="image"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎的垃圾回收机制</title>
    <url>/2022/01/26/v8%E7%9A%84gc%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="V8引擎的垃圾回收机制"><a href="#V8引擎的垃圾回收机制" class="headerlink" title="V8引擎的垃圾回收机制"></a>V8引擎的垃圾回收机制</h1><p>我们首先带着这 4 个问题，来了解V8垃圾回收的过程，后面会逐一解答：</p>
<ol>
<li>V8怎么进行垃圾回收？</li>
<li>V8中不同类型变量的内存都是何时释放？</li>
<li>哪些情况会导致内存泄露？如何避免？</li>
<li><code>weakMap</code> <code>weakSet</code> 和 <code>Map</code> <code>Set</code> 有什么区别？</li>
</ol>
<h1 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h1><p>在一些变量不再被需要的时候，它就是垃圾数据，垃圾数据占用的内存就应该被回收。比如这么一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> dog.<span class="property">a</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>当 JavaScript 执行这段代码的时候，</p>
<p>会先在全局作用域中添加一个<code>dog</code> 属性，并在堆中创建了一个空对象，将该对象的地址指向了 <code>dog</code>。</p>
<p>随后又创建一个大小为 1 的数组，并将属性地址指向了 <code>dog.a</code>。此时的内存布局图如下所示:</p>
<p><img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/9CB21A9D10A25B2CFCEF8A2693141818.jpg" alt="img">如果此时，我将另外一个对象赋给了 <code>a</code> 属性，代码如下所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dog.<span class="property">a</span> = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure>

<p>此时的内存布局图：<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/2D88EADBC1C1C35E1005637CCE49D949.jpg" alt="img"></p>
<p><code>a</code> 的指向改变了， 此时堆中的数组对象就成为了不被使用的数据，专业名词叫「不可达」的数据。</p>
<p>这就是需要回收的垃圾数据。</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>可以将这个过程想象成从根溢出一个巨大的油漆桶，它从一个根节点出发将可到达的对象标记染色， 然后移除未标记的。</p>
<h2 id="标记空间中可达值"><a href="#标记空间中可达值" class="headerlink" title="标记空间中可达值"></a>标记空间中可达值</h2><p>V8 采用的是可达性 (reachability) 算法来判断堆中的对象应不应该被回收。</p>
<p>这个算法的思路是这样的：</p>
<ul>
<li>从根节点（Root）出发，遍历所有的对象。</li>
<li>可以遍历到的对象，是可达的（reachable）。</li>
<li>没有被遍历到的对象，不可达的（unreachable）。</li>
</ul>
<p>在浏览器环境下，根节点有很多，主要包括这几种：</p>
<ul>
<li>全局变量 <code>window</code>，位于每个 <code>iframe</code> 中</li>
<li>文档 <code>DOM</code> 树</li>
<li>存放在栈上的变量</li>
<li>…</li>
</ul>
<p>这些根节点不是垃圾，不可能被回收。</p>
<h2 id="回收不可达的值所占据的内存"><a href="#回收不可达的值所占据的内存" class="headerlink" title="回收不可达的值所占据的内存"></a>回收不可达的值所占据的内存</h2><p>在所有的标记完成之后，统一清理内存中所有不可达的对象。</p>
<h2 id="内存整理"><a href="#内存整理" class="headerlink" title="内存整理"></a>内存整理</h2><ul>
<li>在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。</li>
<li>当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。</li>
<li>所以最后一步是整理内存碎片。(但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。)</li>
</ul>
<h1 id="垃圾回收方式"><a href="#垃圾回收方式" class="headerlink" title="垃圾回收方式"></a>垃圾回收方式</h1><p>V8进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行。</p>
<p>对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂停时间很长就会造成页面卡顿。</p>
<p>这就是我们接下来谈的关于垃圾回收的问题：什么时候进行垃圾回收，可以避免长时间暂停。</p>
<h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>V8将数据分为两种，一种是「临时」对象，一种是「长久」对象。</p>
<ul>
<li><p>临时对象：</p>
</li>
<li><ul>
<li>大部分对象在内存中存活的时间很短。</li>
<li>比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。</li>
<li>这类对象很快就变得不可访问，应该快点回收。</li>
</ul>
</li>
<li><p>长久对象：</p>
</li>
<li><ul>
<li>生命周期很长的对象，比如全局的 <code>window、DOM、Web API</code> 等等。</li>
<li>这类对象可以慢点回收。</li>
</ul>
</li>
</ul>
<p>这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域， 新生代中存放临时对象，老生代中存放持久对象。</p>
<p>并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。</p>
<p>这样就可以实现高效的垃圾回收啦。</p>
<p>一般来说，面试回答到这就够了。如果想和面试官深入交流，可以继续聊聊两个垃圾回收器。</p>
<h3 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h3><p>负责老生代的垃圾回收，有两个特点：</p>
<ol>
<li>对象占用空间大。</li>
<li>对象存活时间长。</li>
</ol>
<p>它使用「标记-清除」的算法执行垃圾回收。</p>
<ol>
<li>首先是标记。</li>
</ol>
<ul>
<li>从一组根元素开始，递归遍历这组根元素。</li>
<li>在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li>
</ul>
<p>然后是垃圾清除。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/BDDC2A2EDC0D87EFD594C41B20A5FCEC.jpg" alt="img">直接将标记为垃圾的数据清理掉。</p>
<p>多次标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/A4BD5AEEF4FF19858B823BDFB82E879B.jpg" alt="img"></p>
<h3 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h3><p>负责新生代的垃圾回收，通常只支持 1~8 M 的容量。</p>
<p>新生代被分为两个区域：一般是对象区域，一半是空闲区域。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/1F8C55A87A1DAAED998BFE1729BF604C.jpg" alt="img">新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。</p>
<ol>
<li>先给对象区域所有垃圾做标记。</li>
<li>标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/9AFA85C62E23E5BFE7BCC02989E14FDF.jpg" alt="img">这就回到我们前面留下的问题 – 副垃圾回收器没有碎片整理。因为空闲区域里此时是有序的，没有碎片，也就不需要整理了。</li>
<li>复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/932E7BB81521530505384FF56A59DF48.jpg" alt="img">这样，就完成了垃圾回收。</li>
</ol>
<p>因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>
<p>一旦检测到空间装满了，就执行垃圾回收。</p>
<h3 id="分代收集-1"><a href="#分代收集-1" class="headerlink" title="分代收集"></a>分代收集</h3><p>一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。</p>
<p>这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/F03806EE24DA9A564E0BC3ECAD500DFD.jpg" alt="img"></p>
<h2 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h2><p>如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。</p>
<p>所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。</p>
<p>这样就解决了长时间停顿的问题。<img src="https://image.z.itpub.net/zitpub.net/JPG/2020-11-16/97A76334ACE67AC1FC3022376EDCC27E.jpg" alt="img"></p>
<h2 id="闲时收集"><a href="#闲时收集" class="headerlink" title="闲时收集"></a>闲时收集</h2><p>垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</p>
<h1 id="关于V8-GC的一些问题"><a href="#关于V8-GC的一些问题" class="headerlink" title="关于V8 GC的一些问题"></a>关于V8 GC的一些问题</h1><h2 id="问题1：V8怎么进行垃圾回收？"><a href="#问题1：V8怎么进行垃圾回收？" class="headerlink" title="问题1：V8怎么进行垃圾回收？"></a>问题1：V8怎么进行垃圾回收？</h2><p>从三个点来回答什么是垃圾、如何捡垃圾、什么时候捡垃圾。</p>
<ol>
<li>什么是垃圾</li>
</ol>
<ul>
<li>不再需要，即为垃圾</li>
<li>全局变量随时可能用到，所以一定不是垃圾</li>
</ul>
<p>如何捡垃圾（遍历算法）</p>
<ul>
<li><p>标记空间中「可达」值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 从根节点（Root）出发，遍历所有的对象。</span><br><span class="line">- 可以遍历到的对象，是可达的（reachable）。</span><br><span class="line">- 没有被遍历到的对象，不可达的（unreachable）</span><br></pre></td></tr></table></figure></li>
<li><p>回收「不可达」的值所占据的内存。</p>
</li>
<li><p>做内存整理。</p>
</li>
</ul>
<p>什么时候捡垃圾</p>
<ul>
<li>前端有其特殊性，垃圾回收的时候会造成页面卡顿。</li>
<li>分代收集、增量收集、闲时收集。</li>
</ul>
<h2 id="问题2：V8中不同类型变量的内存都是何时释放？"><a href="#问题2：V8中不同类型变量的内存都是何时释放？" class="headerlink" title="问题2：V8中不同类型变量的内存都是何时释放？"></a>问题2：V8中不同类型变量的内存都是何时释放？</h2><p>Javascritp 中类型：值类型，引用类型。</p>
<ul>
<li><p>引用类型</p>
<ul>
<li>在没有引用之后，通过 V8 自动回收。</li>
</ul>
</li>
<li><p>值类型</p>
<ul>
<li>如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收。</li>
</ul>
<ul>
<li>非闭包的情况下，等待 V8 的新生代切换的时候回收。</li>
</ul>
</li>
</ul>
<h2 id="问题3：哪些情况会导致内存泄露？如何避免？"><a href="#问题3：哪些情况会导致内存泄露？如何避免？" class="headerlink" title="问题3：哪些情况会导致内存泄露？如何避免？"></a>问题3：哪些情况会导致内存泄露？如何避免？</h2><blockquote>
<p>内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。</p>
</blockquote>
<p>以 Vue 为例，通常有这些情况：</p>
<ul>
<li>监听在 <code>window/body</code> 等事件没有解绑</li>
<li>绑在 <code>EventBus</code> 的事件没有解绑</li>
<li><code>Vuex</code> 的 <code>$store</code>，<code>watch</code> 了之后没有 <code>unwatch</code></li>
<li>使用第三方库创建，没有调用正确的销毁函数</li>
</ul>
<p>解决办法：<code>beforeDestroy</code> 中及时销毁</p>
<ul>
<li>绑定了 <code>DOM/BOM</code> 对象中的事件 <code>addEventListener</code> ，<code>removeEventListener</code>。</li>
<li>观察者模式 <code>$on</code>，<code>$off</code>处理。</li>
<li>如果组件中使用了定时器，应销毁处理。</li>
<li>如果在 <code>mounted/created</code> 钩子中使用了第三方库初始化，对应的销毁。</li>
<li>使用弱引用 <code>weakMap</code>、<code>weakSet</code>。</li>
</ul>
<h3 id="闭包会导致内存泄露吗？"><a href="#闭包会导致内存泄露吗？" class="headerlink" title="闭包会导致内存泄露吗？"></a>闭包会导致内存泄露吗？</h3><p>顺便说一个我在了解垃圾回收之前对闭包的误解。</p>
<p>闭包会导致内存泄露吗？正确的答案是不会。</p>
<p>内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。</p>
<blockquote>
<p>这个误解是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。</p>
</blockquote>
<h2 id="问题4：weakMap-weakSet-和-Map-Set-有什么区别？"><a href="#问题4：weakMap-weakSet-和-Map-Set-有什么区别？" class="headerlink" title="问题4：weakMap weakSet 和 Map Set 有什么区别？"></a>问题4：<code>weakMap</code> <code>weakSet</code> 和 <code>Map</code> <code>Set</code> 有什么区别？</h2><p>在 ES6 中为我们新增了两个数据结构 <code>WeakMap</code>和<code>WeakSet</code>就是为了解决内存泄漏的问题。</p>
<p>它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要， <code>WeakMap</code>里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我们简单了解了V8的垃圾回收机制，还记得最初的 4 个问题吗？</p>
<ol>
<li>V8怎么进行垃圾回收？</li>
</ol>
<p>答题思路：什么是垃圾、怎么收垃圾、什么时候收垃圾。</p>
<ol start="2">
<li>V8中不同类型变量的内存都是何时释放？</li>
</ol>
<p>答题思路：分为值类型、引用类型。</p>
<ol start="3">
<li>哪些情况会导致内存泄露？如何避免？</li>
</ol>
<p>答题思路：内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。</p>
<ol start="4">
<li><code>weakMap</code> <code>weakSet</code> 和 <code>Map</code> <code>Set</code> 有什么区别？</li>
</ol>
<p>答题思路：<code>WeakMap</code>、<code>WeakSet</code> 弱引用，解决了内存泄露问题。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>V8</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Github Actions 自动部署 Hexo 博客</title>
    <url>/2022/01/28/%E5%88%A9%E7%94%A8%20Github%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo%20%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Github Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。在 Travis 全面收费之后，笔者不得不换一个 CI 平台来完成自动化部署，便有了这篇文章。</p>
<p>本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages。在之前我们需要写完文章后在本地执行 <code>hexo g -d</code> 来部署，当你文章比较多的时候，编译部署需要等待很长时间。而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，需要用 <code>nvm</code> 来管理不同版本的Node.js（其实主要还是因为懒）。。利用 Github Actions 你将会没有这些烦恼，仅需要把Hexo项目pull到本地，把本地写好的文章放入项目的 <code>_posts</code> 文件夹下然后 push，Actions将自动部署更新。</p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><h2 id="创建所需仓库"><a href="#创建所需仓库" class="headerlink" title="创建所需仓库"></a>创建所需仓库</h2><p>本文仅用一个仓库存储静态文件和hexo项目，分不同的branch存储：</p>
<ol>
<li>创建 <code>blog</code> 分支用来存放 Hexo 项目</li>
<li>创建 <code>main</code> 分支用来存放静态博客页面</li>
</ol>
<h2 id="生成部署密钥"><a href="#生成部署密钥" class="headerlink" title="生成部署密钥"></a>生成部署密钥</h2><p>一路按回车直到生成成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -f github-deploy-key</span><br></pre></td></tr></table></figure>

<p>当前目录下会有 <code>github-deploy-key</code> 和 <code>github-deploy-key.pub</code> 两个文件。</p>
<p><img src="https://user-images.githubusercontent.com/33454514/151518040-6204df2e-413e-40c0-bb9f-2dbcf61b35f2.png" alt="image"></p>
<h2 id="配置部署密钥"><a href="#配置部署密钥" class="headerlink" title="配置部署密钥"></a>配置部署密钥</h2><p>复制 <code>github-deploy-key</code> 文件内容，在 <code>blog</code> 仓库 <code>Settings -&gt; Secrets -&gt; Actions -&gt; Add a new secret</code> 页面上添加。</p>
<ol>
<li>在 <code>Name</code> 输入框填写 <code>HEXO_DEPLOY_PRI</code>。</li>
<li>在 <code>Value</code> 输入框填写 <code>github-deploy-key</code> 文件内容（以<code>-----BEGIN OPENSSH PRIVATE KEY-----</code>开头）。</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/33454514/151518361-36101e8d-db94-4362-b7f7-6e9497ce0880.png" alt="image"></p>
<p>复制 <code>github-deploy-key.pub</code> 文件内容，在 <code>your.github.io</code> 仓库 <code>Settings -&gt; Deploy keys -&gt; Add deploy key</code> 页面上添加。</p>
<ol>
<li>在 <code>Title</code> 输入框填写 <code>HEXO_DEPLOY_PUB</code>。</li>
<li>在 <code>Key</code> 输入框填写 <code>github-deploy-key.pub</code> 文件内容。<img src="https://user-images.githubusercontent.com/33454514/151518605-f89c8566-d231-4cdc-9cd7-ca6cad0eecd4.png" alt="image"></li>
<li>勾选 <code>Allow write access</code> 选项。<img src="https://user-images.githubusercontent.com/33454514/151518731-37a7c402-a78f-40b0-a25a-9f8d742fa053.png" alt="image"></li>
</ol>
<h1 id="编写-Github-Actions"><a href="#编写-Github-Actions" class="headerlink" title="编写 Github Actions"></a>编写 Github Actions</h1><h2 id="Workflow-模版"><a href="#Workflow-模版" class="headerlink" title="Workflow 模版"></a>Workflow 模版</h2><p>在仓库的 <code>blog</code> 分支下根目录下创建 <code>.github/workflows/deploy.yml</code> 文件，目录结构如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog</span><br><span class="line">└─ .github</span><br><span class="line">    └─ workflows</span><br><span class="line">        └─ deploy.yml</span><br></pre></td></tr></table></figure>

<p>在 <code>deploy.yml</code> 文件中粘贴以下内容。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">yourname</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">yourname@example.com</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">yourname/yourname.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [ <span class="string">ubuntu-latest</span> ]</span><br><span class="line">        <span class="attr">node_version:</span> [ <span class="number">12.</span><span class="string">x</span> ]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">deploy</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_BUILD_PRI</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name $GIT_USER</span></span><br><span class="line"><span class="string">          git config --global user.email $GIT_EMAIL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></table></figure>

<h2 id="模版参数说明"><a href="#模版参数说明" class="headerlink" title="模版参数说明"></a>模版参数说明</h2><ul>
<li><code>name</code>为此 Action 的名字</li>
<li><code>on</code>触发条件，当满足条件时会触发此任务，这里的 <code>on.push.branches.blog</code> 是指当 <code>blog</code> 分支收到 <code>push</code> 后执行任务。</li>
<li>env为环境变量对象<ul>
<li><code>env.GIT_USER</code> 为 Hexo 编译后使用此 git 用户部署到仓库。</li>
<li><code>env.GIT_EMAIL</code> 为 Hexo 编译后使用此 git 邮箱部署到仓库。</li>
<li><code>env.DEPLOY_REPO</code> 为 Hexo 编译后要部署的仓库，例如：<code>zhsama/zhsama.github.io</code>。</li>
<li><code>env.DEPLOY_BRANCH</code> 为 Hexo 编译后要部署到的分支，例如：master。</li>
</ul>
</li>
<li>jobs为此 Action 下的任务列表<ul>
<li><code>jobs.&#123;job&#125;.name</code> 任务名称</li>
<li><code>jobs.&#123;job&#125;.runs-on</code> 任务所需容器，可选值：<code>ubuntu-latest</code>、<code>windows-latest</code>、<code>macos-latest</code>。</li>
<li><code>jobs.&#123;job&#125;.strategy</code> 策略下可以写 <code>array</code> 格式，此 job 会遍历此数组执行。</li>
<li><code>jobs.&#123;job&#125;.steps</code>一个步骤数组，可以把所要干的事分步骤放到这里。<ul>
<li><code>jobs.&#123;job&#125;.steps.$.name</code> 步骤名，编译时会会以 LOG 形式输出。</li>
<li><code>jobs.&#123;job&#125;.steps.$.uses</code> 所要调用的 Action，可以到 <a href="https://github.com/actions">https://github.com/actions</a> 查看更多。</li>
<li><code>jobs.&#123;job&#125;.steps.$.with</code> 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>最终目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog</span><br><span class="line">└─ .github</span><br><span class="line">    └─ workflows</span><br><span class="line">        └─ deploy.yml</span><br></pre></td></tr></table></figure>

<p>把 <code>deploy.yml</code> 文件推送到 <code>blog</code> 分支，在此仓库 <code>Actions</code> 页面可以看到一个名字为 <code>HEXO</code> 的 Action。</p>
<h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>写一篇文章，<code>push</code> 到仓库的 <code>blog</code> 分支，在此仓库 <code>Actions</code> 页面查看当前的task。</p>
<p><img src="https://user-images.githubusercontent.com/33454514/151520844-e97f8697-3501-4edf-9d05-56271db059ef.png" alt="image"></p>
<p>当任务完成后查看您的博客 <code>https://your.github.io</code>，如果不出意外的话已经可以看到新添加的文章了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>偷懒是人类发展的最大动力！！！还是微软爸爸有钱，Actions免费用，这样我的守望先锋2是不是未来可期了啊？🤤🤤🤤</p>
]]></content>
      <categories>
        <category>CI</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Github Actions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常见 HTTP 状态码</title>
    <url>/2022/03/16/%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>状态码（Status Code）和原因短语（Reason Phrase）用于<strong>描述请求的结果</strong>。常见的比如：</p>
<ul>
<li>200 OK，表示请求成功；</li>
<li>404 Not Found表示请求的资源未找到。</li>
</ul>
<p>原因短语（上面的ok 和Not Found）是对状态码的解释说明。</p>
<p>形如<code>200</code>这样的状态码，这里的第1位数字，通常表示响应的类别，大致可以分成以下几类：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td align="left">请求正被处理</td>
</tr>
<tr>
<td>2xx</td>
<td align="left">请求成功处理</td>
</tr>
<tr>
<td>3xx</td>
<td align="left">请求需要附加操作，常见的例子如重定向</td>
</tr>
<tr>
<td>4xx</td>
<td align="left">客户端出错导致请求无法被处理</td>
</tr>
<tr>
<td>5xx</td>
<td align="left">服务端处理出错</td>
</tr>
</tbody></table>
<span id="more"></span>
<h1 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h1><h2 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h2><p>表示请求已经被正常处理，这个比较常见，就不在这赘述了。</p>
<h2 id="204-NO-Content"><a href="#204-NO-Content" class="headerlink" title="204 NO Content"></a>204 NO Content</h2><blockquote>
<p>表示请求成功，但是响应的报文中不含实体主体。通常用于只需要客户端向服务端发送信息，而不需要接受新信息的情况使用</p>
</blockquote>
<p>说话人就是：有一种常见的种请求类型<code>options</code>，通常被用来做正式请求的预请求，这个请求<strong>只需要确认后续的请求能不能通过，即只需要一个结果，而不需要返回其他内容</strong>，这类请求成功时就会返回204。</p>
<h2 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h2><p>字面意思：客户端进行了范围请求，而服务器成功执行了这部分请求。这种情况必须提到提到一个请求头<code>Range</code>：在 http 的请求中，这个头部用来表示<strong>范围请求</strong>。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Range&#x27;</span>:byte=<span class="number">5001</span>-<span class="number">10000</span> <span class="regexp">//</span> 表示本次要请求资源的<span class="number">5001</span>-<span class="number">10000</span>字节的部分</span><br></pre></td></tr></table></figure>

<p>这种情况下，如果服务器接受范围请求并且成功处理，就会返回<code>206</code>,并且在响应的头部返回：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Content-Range&#x27;</span>:<span class="built_in">bytes</span> <span class="number">5001</span><span class="number">-10000</span>/<span class="number">10000</span> <span class="comment">// 表示整个资源有10000字节，本次返回的范围为 5001-10000字节</span></span><br></pre></td></tr></table></figure>

<h1 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h1><h2 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h2><p>字面意思：资源被<strong>永久</strong>重定向了。这种情况下响应的头部字段<code>Location</code>中一般还会返回一个地址，用来表示要新地址。例如：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span> Moved Permanently </span><br><span class="line"><span class="params">...</span></span><br><span class="line">Location:<span class="string">&#x27;b.com&#x27;</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端请求的资源已被永久转移，需对新地址 b.com 访问，以后的请求直接访问新地址</span></span><br></pre></td></tr></table></figure>

<h2 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h2><p>字面意思：资源<strong>临时</strong>重定向了。还是举上面的例子：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="number">302</span> Found</span><br><span class="line"><span class="params">...</span></span><br><span class="line">Location: <span class="string">&#x27;b.com&#x27;</span></span><br><span class="line"><span class="params">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述内容表示：客户端请求的资源被临时转移，后面也有可能再次转移，本次请求访问新地址 b.com，以后的请求还是先访问原来地址。</span></span><br></pre></td></tr></table></figure>

<h2 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h2><p>这个和302很像，但是有个细微区别是，除了会提示客户端去请求<code>Location</code>以外，还会要求请求要使用<code>Location</code>时使用<code>GET</code>方法。 在这补充一下一个历史背景：</p>
<blockquote>
<p>请求返回301 302 303 时，几乎所有浏览器都会把原先的POST请求改为GET请求。虽然FRC1945和RFC2068规范中有规定：不允许客户端在重定向时修改方法。</p>
</blockquote>
<p>简单的说，实际的浏览器在处理301和302时，默认就会把原先的POST请求改为GET请求，所以实际上使用303的意义，单纯只是让语义化更清晰点。（303表示服务器<strong>明确告诉</strong>客户端，你要使用<code>GET</code>方法访问<code>location</code>。如果是302，就是仅仅告诉客户端要访问<code>location</code>，不限制方法，但是实际上客户端自己也会用<code>GET</code>方法访问。）</p>
<blockquote>
<p>注意：当301，302，303响应状态码返回时，几乎所有的浏览器会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送</p>
</blockquote>
<h2 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h2><p> 服务器端资源未改变，可直接使用客户端未过期的缓存，不包含任何响应的主体部分。304是3xx里面的一个特例，因为它不算是一个重定向。</p>
<p>这种响应一般是<code>GET</code>请求中带有<strong>附加条件</strong>，例如请求头中含有<code>if-Match</code>，<code>if-Modified-Since</code>等。</p>
<p><code>if-Match</code>表示只请求带有特殊标记的资源，<code>if-Modified-Since</code>表示请求指定时间后未变更的资源。</p>
<h1 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h1><p>4xx表示一般是客户端发生了错误。</p>
<h2 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h2><p>400的含义简单粗暴：请求中有语法错误。那具体是什么语法错误呢?一般来说响应报文里会有一些提示，例如：</p>
<ul>
<li>多加了请求头</li>
<li>请求地址错误导，该 uri 不存在</li>
<li>请求方法错误，该 uri 之只能用 put 而不是 post</li>
<li>…</li>
</ul>
<h2 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h2><p>字面意思：未经过认证。一般在后台系统之类的应用里，用户登录之后会获得一个身份认证信息，然后生成<code>mac</code>之类的信息，放在请求头的<code>Authorization</code>字段里，发送给服务端，如果这个认证信息有问题或者根本没发送，就会出现这个状态码。</p>
<h2 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h2><p>这个就简单了：禁止访问也就是无权限访问。禁止原因一般由服务器在响应内中给出。</p>
<h2 id="404-Not-Find"><a href="#404-Not-Find" class="headerlink" title="404 Not Find"></a>404 Not Find</h2><p>这个错误可以说是很常见了，表示服务端没有找到所请求的资源。（经验表明，一般这个错误是客户端的请求url写错了。）</p>
<h1 id="499-Client-Has-Closed-Connection"><a href="#499-Client-Has-Closed-Connection" class="headerlink" title="499 Client Has Closed Connection"></a>499 Client Has Closed Connection</h1><p>服务器端处理的时间过长，客户端主动断开链接，nginx定义的状态码。</p>
<h1 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h1><p>5xx表明服务端发生了错误。</p>
<h2 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h2><p>简单粗暴，服务器故障了。啥？你问我什么故障？我哪知道，我只会熟练地把bug转给隔壁的服务端同学。</p>
<h2 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h2><p>作为<strong>网关</strong>或者<strong>代理</strong>工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。这里说明下网关和代理服务器的概念：前面我们举例子都是直接客户端向服务器发请求，实际上客户端有时候不是直接向服务器请求，这中间可能存在网关和代理：</p>
<ul>
<li><strong>代理</strong>连接的是两个或多个使用相同协议的应用程序。</li>
<li><strong>网关</strong>连接的是两个或多个使用不同协议的端点，扮演“协议转换器”的角色。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/33454514/157812931-33161215-7936-431d-a6c0-215718fa6044.png" alt="image"></p>
<h2 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h2><p>服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p>
<h2 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h2><p>作为<strong>网关</strong>或者<strong>代理</strong>工作的服务器访问超时。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 XSS 和 CRFS 攻击</title>
    <url>/2022/03/30/%E6%B5%85%E8%B0%88%20XSS%20%E5%92%8C%20CRFS%20%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端技术人员不断进行“查漏补缺”。</p>
<span id="more"></span>

<h1 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h1><p><code>XSS</code> 全称是 <code>Cross Site Scripting</code>（即<code>跨站脚本</code>），为了和 CSS 区分，故叫它<code>XSS</code>。XSS 攻击是指浏览器中执行恶意脚本（无论是跨域还是同域），从而拿到用户的信息并进行操作。</p>
<p>这些操作一般可以完成下面这些事情:</p>
<ol>
<li>窃取<code>Cookie</code>。</li>
<li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li>
<li>修改 DOM 伪造登录表单。</li>
<li>在页面中生成浮窗广告。</li>
</ol>
<h1 id="XSS-攻击类型"><a href="#XSS-攻击类型" class="headerlink" title="XSS 攻击类型"></a>XSS 攻击类型</h1><p>通常情况，XSS 攻击的实现有三种方式——<strong>存储型</strong>、<strong>反射型</strong>和<strong>文档型</strong>。原理都比较简单，先来一一介绍一下。</p>
<h2 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h2><p>存储型，顾名思义就是存储恶意脚本，实际应用中通常是将恶意脚本存储到服务端的数据库，在客户请求时返回恶意脚本并执行，从而达到攻击的效果。</p>
<p>常见的场景是在留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，评论内容就将被存储到数据库，并在页面渲染过程中直接执行，相当于执行一段未知逻辑的 JS 代码。</p>
<h2 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h2><p><code>反射型XSS</code>指的是恶意脚本作为<strong>网络请求的一部分</strong>。</p>
<p>比如输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://sanyuan.com?q=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这样，在服务器端会拿到<code>q</code>参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。</p>
<p>之所以叫它<code>反射型</code>, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和<code>存储型</code>不一样的是，服务器并不会存储这些恶意脚本。</p>
<h2 id="文档（DOM）型"><a href="#文档（DOM）型" class="headerlink" title="文档（DOM）型"></a>文档（DOM）型</h2><p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改响应中的 html 文档。</p>
<p>这样的劫持方式包括<code>WIFI路由器劫持</code>或者<code>本地恶意软件</code>等。</p>
<h1 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h1><p>明白了三种<code>XSS</code>攻击的原理，我们能发现一个共同点：恶意脚本直接能在浏览器中执行。那么要防范它，就是要避免这些脚本代码的执行。</p>
<h2 id="过滤用户的输入信息"><a href="#过滤用户的输入信息" class="headerlink" title="过滤用户的输入信息"></a>过滤用户的输入信息</h2><p>千万不要相信任何用户的输入！无论是在前端和服务端，都要对用户的输入进行<strong>转码</strong>或者<strong>过滤</strong>。</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>转码后变为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;<span class="title function_">alert</span>(&amp;#<span class="number">39</span>;xss&amp;#<span class="number">39</span>;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<p>这样的代码在 html 解析的过程中是无法执行的。</p>
<p>当然也可以利用关键词过滤的方式，将 script 标签给删除。</p>
<h2 id="利用-CSP"><a href="#利用-CSP" class="headerlink" title="利用 CSP"></a>利用 CSP</h2><p>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:</p>
<ol>
<li>限制其他域下的资源加载。</li>
<li>禁止向其它域提交数据。</li>
<li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li>
</ol>
<h2 id="利用-HttpOnly"><a href="#利用-HttpOnly" class="headerlink" title="利用 HttpOnly"></a>利用 HttpOnly</h2><p>很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p>
<h1 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h1><p>CSRF（Cross-site request forgery），即跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act=xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ul>
<h1 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h1><h2 id="自动发-GET-请求"><a href="#自动发-GET-请求" class="headerlink" title="自动发 GET 请求"></a>自动发 GET 请求</h2><p>黑客网页里面可能有一段这样的代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。</p>
<p>假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p>
<h2 id="自动发-POST-请求"><a href="#自动发-POST-请求" class="headerlink" title="自动发 POST 请求"></a>自动发 POST 请求</h2><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;hacker-form&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;https://xxx.com/info&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hhh&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hacker-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p>
<h2 id="诱导点击发送-GET-请求"><a href="#诱导点击发送-GET-请求" class="headerlink" title="诱导点击发送 GET 请求"></a>诱导点击发送 GET 请求</h2><p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>屠龙宝刀点击就送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击后，自动发送 get 请求，接下来和<code>自动发 GET 请求</code>部分同理。</p>
<p>这就是<code>CSRF</code>攻击的原理。和<code>XSS</code>攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的<code>html</code>文档中，而是跳转到新的页面，利用服务器的<strong>验证漏洞</strong>和<strong>用户之前的登录状态</strong>来模拟用户进行操作。</p>
<h1 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h1><h2 id="利用-Cookie-的-SameSite-属性"><a href="#利用-Cookie-的-SameSite-属性" class="headerlink" title="利用 Cookie 的 SameSite 属性"></a>利用 Cookie 的 SameSite 属性</h2><p><code>CSRF攻击</code>中重要的一环就是自动发送目标站点下的 <code>Cookie</code>,然后就是这一份 Cookie 模拟了用户的身份。因此在<code>Cookie</code>上面下文章是防范的不二之选。</p>
<p>恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是<code>SameSite</code>。</p>
<p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p>
<ol>
<li><p><code>Strict</code>模式：浏览器完全禁止第三方请求携带Cookie。比如说 b.com 设置了如下 Cookie：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: foo=1; Samesite=Strict</span><br><span class="line">Set-Cookie: bar=2; Samesite=Lax</span><br><span class="line">Set-Cookie: baz=3</span><br></pre></td></tr></table></figure>

<p>我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</p>
</li>
<li><p><code>Lax</code>模式：比 Strict 放宽了点限制，假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie</p>
</li>
<li><p><code>None</code>模式：也就是默认模式，请求会自动携带上 Cookie。</p>
</li>
</ol>
<h2 id="验证来源站点"><a href="#验证来源站点" class="headerlink" title="验证来源站点"></a>验证来源站点</h2><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>
<ul>
<li>Origin Header</li>
<li>Referer Header</li>
</ul>
<p>其中，<strong>Origin</strong> 只包含域名信息，而 <strong>Referer</strong> 包含了具体的 URL 路径。</p>
<h3 id="使用Origin-Header确定来源域名"><a href="#使用Origin-Header确定来源域名" class="headerlink" title="使用Origin Header确定来源域名"></a>使用Origin Header确定来源域名</h3><p>在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含 path 及 query）。</p>
<p>如果 Origin 存在，那么直接使用 Origin中的字段确认来源域名就可以。</p>
<p>但是在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</p>
<h3 id="使用Referer-Header确定来源域名"><a href="#使用Referer-Header确定来源域名" class="headerlink" title="使用Referer Header确定来源域名"></a>使用Referer Header确定来源域名</h3><p>在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>
<p>这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。</p>
<h2 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h2><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>
<p>CSRF Token的防护策略分为三个步骤：</p>
<p><strong>1. 将CSRF Token输出到页面中</strong></p>
<p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p>
<p><strong>2. 页面提交的请求携带这个Token</strong></p>
<p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue">http://url?csrftoken=tokenvalue</a></p>
<p>而对于 POST 请求来说，要在 form 的最后加上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">”hidden”</span> <span class="attr">name</span>=<span class="string">”csrftoken”</span> <span class="attr">value</span>=<span class="string">”tokenvalue”/</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，就把Token以参数的形式加入请求了。</p>
<p><strong>3. 服务器验证Token是否正确</strong></p>
<p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p>
<p>这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><code>XSS</code> 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为<code>存储型</code>、<code>反射型</code>和<code>文档型</code>。防范的措施包括：</p>
<ul>
<li>对用户的输入内容进行转码或者过滤，让其不可执行。</li>
<li>利用 CSP 或利用 Cookie 的 HttpOnly 属性。</li>
</ul>
<h2 id="CFRS"><a href="#CFRS" class="headerlink" title="CFRS"></a>CFRS</h2><p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p>
<p><code>CSRF</code>攻击一般会有三种方式:</p>
<ul>
<li>自动 GET 请求</li>
<li>自动 POST 请求</li>
<li>诱导点击发送 GET 请求。</li>
</ul>
<p>防范措施: 利用 Cookie 的 SameSite 属性、验证来源站点和CSRF Token。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基础及易混淆的概念</title>
    <url>/2021/10/05/webpack%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>Webpack 有非常多的概念，很多名词长得都差不多。本文旨在将这些分散在文档和教程里的内容总结起来，完成一份 webpack 中的易混淆知识点集合。</p>
<span id="more"></span>
<h1 id="module，chunk-和-bundle-的区别"><a href="#module，chunk-和-bundle-的区别" class="headerlink" title="module，chunk 和 bundle 的区别"></a>module，chunk 和 bundle 的区别</h1><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>webpack 官网对 chunk 和 bundle 的解释过于抽象。为方便理解，我这里举个例子给大家形象化的解释一下。</p>
<p>我们在 src 目录下引入 index.js、utils.js、common.js 和 index.css 这 4 个文件，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">├── index.css</span><br><span class="line">├── index.html # HTML 模板代码</span><br><span class="line">├── index.js</span><br><span class="line">├── common.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure>
<p>index.css 的内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>utils.js 的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> n1 = <span class="number">1</span>, n2 = <span class="number">1</span>, sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum = n1 + n2</span><br><span class="line">    n1 = n2</span><br><span class="line">    n2 = sum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>common.js 的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">log</span>: <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js 的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Common</span> <span class="keyword">from</span> <span class="string">&#x27;./common.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Common</span>.<span class="title function_">log</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>webpack 的配置如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">utils</span>: <span class="string">&#x27;../src/utils.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].bundle.js&quot;</span>, <span class="comment">// 输出 index.js 和 utils.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="comment">// 创建一个 link 标签</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// css-loader 负责解析 CSS 代码, 处理 CSS 中的依赖</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 用 MiniCssExtractPlugin 抽离出 css 文件，以 link 标签的形式引入样式文件</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.bundle.css&#x27;</span> <span class="comment">// 输出的 css 文件名为 index.css</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 webpack后包的结果：<br><img src="https://user-images.githubusercontent.com/33454514/135892008-9f99b7f4-582c-4089-9107-aced8feb8621.png" alt="image"></p>
<p>由上图可以看出，<code>index.css</code> 和 <code>common.js</code> 在 <code>index.js</code> 中被引入，打包生成的 <code>index.bundle.css</code> 和 <code>index.bundle.js</code> 都属于 <code>chunk 0</code>，<code>utils.js</code> 因为是独立打包的，它生成的 <code>utils.bundle.js</code> 属于 <code>chunk 1</code>。</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135892433-d8191708-0dc5-4b78-84aa-057fbdf985b2.png" alt="image"></p>
<p>看这个图就很明白了：</p>
<ol>
<li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；</li>
<li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；</li>
<li>webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。<br>一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -&gt; chunks 1 -&gt; utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><code>module</code>，<code>chunk</code> 和 <code>bundle</code> 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：</li>
</ol>
<p>我们直接写出来的是 <code>module</code>，<code>webpack</code> 处理时是 <code>chunk</code>，最后生成浏览器可以直接运行的 <code>bundle</code>。</p>
<h1 id="filename-和-chunkFilename-的区别"><a href="#filename-和-chunkFilename-的区别" class="headerlink" title="filename 和 chunkFilename 的区别"></a>filename 和 chunkFilename 的区别</h1><h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p><code>filename</code> 是一个很常见的配置，就是对应于 <code>entry</code> 里面的输入文件，<code>经过webpack</code> 打包后输出文件的文件名。比如说经过下面的配置，生成出来的文件名为 <code>index.min.js</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].min.js&quot;</span>, <span class="comment">// index.min.js</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/33454514/135893374-3f5620a6-e9d5-46b6-b65a-0c4afbb3ebb1.png" alt="image"></p>
<h2 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h2><p><code>chunkFilename</code> 指未被列在 <code>entry</code> 中，却又需要被打包出来的 <code>chunk</code> 文件的名称。一般来说，这个 <code>chunk</code> 文件指的就是要懒加载的代码。</p>
<p>比如在代码中写了一份懒加载 lodash 的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 button</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">btn.<span class="property">innerHTML</span> = <span class="string">&quot;click me&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(btn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAsyncComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">  element.<span class="property">innerHTML</span> = _.<span class="title function_">join</span>([<span class="string">&#x27;Hello!&#x27;</span>, <span class="string">&#x27;dynamic&#x27;</span>, <span class="string">&#x27;imports&#x27;</span>, <span class="string">&#x27;async&#x27;</span>], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击 button 时，懒加载 lodash，在网页上显示 Hello! dynamic imports async</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">getAsyncComponent</span>().<span class="title function_">then</span>(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(component);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>webpack</code> 配置不做任何变动，这时候的打包结果如下：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135893745-8d0773ff-65dd-446d-ad7f-eccf25bc76e9.png" alt="image"><br>这个 <code>1.min.js</code> 就是异步加载的 <code>chunk</code> 文件。官方文档的解释如下：</p>
<blockquote>
<p><code>output.chunkFilename</code> 默认使用 <code>[id].js</code> 或从 <code>output.filename</code> 中推断出的值（<code>[name]</code> 会被预先替换为 <code>[id]</code> 或 <code>[id].</code>）</p>
</blockquote>
<p>结合上面的例子来看：</p>
<p><code>output.filename</code> 的输出文件名是 <code>[name].min.js</code>，<code>[name]</code> 根据 <code>entry</code> 的配置推断为 <code>index</code>，所以输出为 <code>index.min.js</code>；</p>
<p>由于 <code>output.chunkFilename</code> 没有显示指定，就会把 <code>[name]</code> 替换为 <code>chunk</code> 文件的 <code>id</code> 号，这里文件的 <code>id</code> 号是 1，所以文件名就是 <code>1.min.js</code>。</p>
<p>如果显式地配置 <code>chunkFilename</code>，就会按配置的名字生成文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name].min.js&quot;</span>,  <span class="comment">// index.min.js</span></span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;bundle.js&#x27;</span>, <span class="comment">// bundle.js</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包的结果如下图：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135894219-b65bd09a-b2cf-434c-9847-ecc5821ca342.png" alt="image"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><code>filename</code> 指列在 <code>entry</code> 中，打包后输出的文件的名称。</p>
<p><code>chunkFilename</code> 指未列在 <code>entry</code> 中，却又需要被打包出来的文件的名称。</p>
<h1 id="webpackPrefetch、webpackPreload-和-webpackChunkName-的区别"><a href="#webpackPrefetch、webpackPreload-和-webpackChunkName-的区别" class="headerlink" title="webpackPrefetch、webpackPreload 和 webpackChunkName 的区别"></a>webpackPrefetch、webpackPreload 和 webpackChunkName 的区别</h1><p>前面举了个异步加载 <code>lodash</code> 的例子，我们最后把 <code>output.chunkFilename</code> 写死成 <code>bundle.js</code>。在我们的业务代码中，不可能只异步加载一个文件，所以写死肯定是不行的，但是写成 <code>[name].bundle.js</code> 时，打包的文件又是意义不明、辨识度不高的 <code>chunk id</code>。</p>
<p>这时候 <code>webpackChunkName</code> 就可以派上用场了。我们可以在 <code>import</code> 文件时，在 <code>import</code> 里以注释的形式为 <code>chunk</code> 文件取别名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getAsyncComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在 import 的括号里 加注释 /* webpackChunkName: &quot;lodash&quot; */ ，为引入的文件取别名</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">  element.<span class="property">innerHTML</span> = _.<span class="title function_">join</span>([<span class="string">&#x27;Hello!&#x27;</span>, <span class="string">&#x27;dynamic&#x27;</span>, <span class="string">&#x27;imports&#x27;</span>, <span class="string">&#x27;async&#x27;</span>], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候打包生成的文件是这样的：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135894906-16f58da4-5910-41bb-933d-b58632b5d5f8.png" alt="image"></p>
<p>现在问题来了，<code>lodash</code> 是我们取的名字，按道理来说应该生成 <code>lodash.bundle.js</code> 啊，前面的 <code>vendors~</code> 是什么玩意？</p>
<p>其实 <code>webpack</code> 懒加载是用内置的一个插件 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 实现的，这个插件里面有些默认 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks">配置项</a> ，比如说 <code>automaticNameDelimiter</code>，默认的分割符就是 <code>~</code>，所以最后的文件名才会出现这个符号。</p>
<h2 id="webpackPrefetch-和-webpackPreload"><a href="#webpackPrefetch-和-webpackPreload" class="headerlink" title="webpackPrefetch 和 webpackPreload"></a>webpackPrefetch 和 webpackPreload</h2><p>这两个配置一个叫预拉取（Preload），一个叫预加载（Prefetch），两者有些细微的不同，我们先说说 <code>webpackPreload</code>。</p>
<p>在上面的懒加载代码里，我们是点击按钮时，才会触发异步加载 lodash 的动作，这时候会动态的生成一个 <code>script</code> 标签，加载到 <code>head</code> 头里：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135895496-b3d2e1b7-1a82-4f92-b1a6-946552410ac3.png" alt="image"></p>
<p>如果我们 <code>import</code> 的时候添加 <code>webpackPrefetch</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="comment">/* webpackPrefetch: true */</span> <span class="string">&#x27;lodash&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>就会以 <link rel="prefetch" as="script"> 的形式预拉取 lodash 代码：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135900665-8bbacb1c-2250-4e35-8807-19dc3ad59f60.png" alt="image"></p>
<p>这个异步加载的代码不需要手动点击 button 触发，webpack 会在父 chunk 完成加载后，闲时加载 lodash 文件。</p>
<p>webpackPreload 是预加载当前导航下可能需要资源，他和 webpackPrefetch 的主要区别是：</p>
<ul>
<li><code>preload chunk</code> 会在父 <code>chunk</code> 加载时，以并行方式开始加载。<code>prefetch chunk</code> 会在父 <code>chunk</code> 加载结束后开始加载。</li>
<li><code>preload chunk</code> 具有中等优先级，并立即下载。<code>prefetch chunk</code> 在浏览器闲置时下载。</li>
<li><code>preload chunk</code> 会在父 <code>chunk</code> 中立即请求，用于当下时刻。<code>prefetch chunk</code>会用于未来的某个时刻</li>
</ul>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><code>webpackChunkName</code> 是为预加载的文件取别名，<code>webpackPrefetch</code> 会在浏览器闲置下载文件，<code>webpackPreload</code> 会在父 <code>chunk</code> 加载时并行下载文件。</p>
<h1 id="hash、chunkhash、contenthash-的区别"><a href="#hash、chunkhash、contenthash-的区别" class="headerlink" title="hash、chunkhash、contenthash 的区别"></a>hash、chunkhash、contenthash 的区别</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p><code>hash</code> 计算是跟整个项目的构建相关，沿用例一中的项目路径。</p>
<p>修改<code>webpack</code> 的核心配置如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">utils</span>: <span class="string">&#x27;../src/utils.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].[hash].js&quot;</span>,  <span class="comment">// 改为 hash</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.[hash].css&#x27;</span> <span class="comment">// 改为 hash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后生成的文件名如下：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135901307-475f7263-9f07-41ec-9dcc-6a883be5d5d5.png" alt="image"></p>
<p>不难发现：生成文件的 <code>hash</code> 和项目的构建 <code>hash</code> 都是一模一样的。</p>
<h2 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h2><p>因为 <code>hash</code> 是项目构建的哈希值，项目中如果有些变动，<code>hash</code> 一定会变，比如修改 <code>utils.js</code> 的代码，<code>index.js</code> 里的代码虽然没有改变，但是大家都是用的同一份 <code>hash</code>。<code>hash</code> 一变，缓存一定失效了，这样子是没办法实现 CDN 和浏览器缓存的。</p>
<p><code>chunkhash</code> 就是解决这个问题的，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 <code>chunk</code>，生成对应的哈希值。</p>
<p>例如对 <code>utils.js</code> 里文件进行改动：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> n1 = <span class="number">1</span>, n2 = <span class="number">1</span>, sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum = n1 + n2</span><br><span class="line">    n1 = n2</span><br><span class="line">    n2 = sum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">  cube,</span><br><span class="line">  <span class="title class_">Fibonacci</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> utils;</span><br></pre></td></tr></table></figure>

<p>然后把 <code>webpack</code> 里的所有 <code>hash</code> 改为 <code>chunkhash</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">utils</span>: <span class="string">&#x27;../src/utils.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].[chunkhash].js&quot;</span>, <span class="comment">// 改为 chunkhash</span></span><br><span class="line">    &#125;,</span><br><span class="line">          </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.[chunkhash].css&#x27;</span> <span class="comment">// // 改为 chunkhash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/33454514/135901840-cbb01f5f-dec9-4d17-b860-d7bedf02975e.png" alt="image"></p>
<p>我们可以看出，<code>chunk 0</code> 的 <code>hash</code> 都是一样的，<code>chunk 1</code> 的 <code>hash</code> 和上面的不一样。</p>
<p>假设我又把 <code>utils.js</code> 里的 <code>cube()</code> 函数去掉，再打包：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135901951-4ed6daed-263a-44eb-a6e0-8f78cd5fda2f.png" alt="image"></p>
<p>对比可以发现，只有 chunk 1 的 hash 发生变化，chunk 0 的 hash 还是原来的。</p>
<h2 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h2><p>我们更近一步，<code>index.js</code> 和 <code>index.css</code> 同为一个 <code>chunk</code>，如果 <code>index.js</code> 内容发生变化，但是 <code>index.css</code> 没有变化，打包后他们的 <code>hash</code> 都发生变化，这对 <code>css</code> 文件来说是一种浪费。如何解决这个问题呢？</p>
<p><code>contenthash</code> 将根据资源内容创建出唯一 <code>hash</code>，也就是说文件内容不变，<code>hash</code> 就不变。</p>
<p>修改 webpack 的配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">index</span>: <span class="string">&quot;../src/index.js&quot;</span>,</span><br><span class="line">        <span class="attr">utils</span>: <span class="string">&#x27;../src/utils.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;[name].[chunkhash].js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.[contenthash].css&#x27;</span> <span class="comment">// 这里改为 contenthash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对 index.js 文件进行三次修改，打包的结果分别如下图：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135902268-f0b0b2bd-2efb-4f18-bb5d-2603b375720f.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/135902274-7afa84b0-5d2f-4654-a9ba-12899bc2bc8e.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/135902277-535cc6c3-e5cc-4e3b-89d4-e7b3ed1781f5.png" alt="image"></p>
<p>不难看出，<code>css</code> 文件的 <code>hash</code> 始终没有发生改变。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><code>hash</code> 计算与整个项目的构建相关；</p>
<p><code>chunkhash</code> 计算与同一 <code>chunk</code> 内容相关；</p>
<p><code>contenthash</code> 计算与文件内容本身相关。</p>
<h1 id="sourse-map-中-eval、cheap、inline-和-module-的区别"><a href="#sourse-map-中-eval、cheap、inline-和-module-的区别" class="headerlink" title="sourse-map 中 eval、cheap、inline 和 module 的区别"></a>sourse-map 中 eval、cheap、inline 和 module 的区别</h1><p>简单说，Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p>
<p>有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。</p>
<p>官网上的sourcemap种类如下图：<br><img src="https://user-images.githubusercontent.com/33454514/135902685-0e8e17f7-4d43-401a-9fa9-eca8961ba0f4.png" alt="image"></p>
<p>观察后不难发现大部分都是 eval、cheap、inline 和 module这 4 个词排列组合的，于是可以大致归纳为如下四个种类：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>eval</td>
<td>打包后的模块都使用 <code>eval()</code> 执行，行映射可能不准；不产生独立的 <code>map</code> 文件</td>
</tr>
<tr>
<td>cheap</td>
<td>map 映射只显示行不显示列，忽略源自 <code>loader</code> 的 <code>source-map</code></td>
</tr>
<tr>
<td>inline</td>
<td>映射文件以 <code>base64</code> 格式编码，加在 <code>bundle</code> 文件最后，不产生独立的 <code>map</code> 文件</td>
</tr>
<tr>
<td>module</td>
<td>增加对 <code>loader</code> <code>source</code> <code>map</code> 和第三方模块的映射</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p>source-map 是最大而全的，会生成独立 map 文件</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135903295-45c87381-799b-45aa-a79d-460c76e61c40.png" alt="image"></p>
<p>source-map 会显示报错的行列信息：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135903373-dec99574-7ea9-4493-8a8b-e36a7f42a59e.png" alt="image"></p>
<h2 id="cheap-sourse-map"><a href="#cheap-sourse-map" class="headerlink" title="cheap-sourse-map"></a>cheap-sourse-map</h2><p><code>cheap</code> 不会产生列映射，相应的体积会小很多，和 <code>sourse-map</code> 的打包结果比一下发现体积只有原来的 1/4 。</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135903497-64abffc3-551d-41c1-8897-15a531ba0bd9.png" alt="image"></p>
<h2 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h2><p><code>eval-source-map</code> 会以 <code>eval()</code> 函数打包运行模块，不产生独立的 <code>map</code> 文件，会显示报错的行列信息：</p>
<p><img src="https://user-images.githubusercontent.com/33454514/135903556-9a39d9ad-be3d-469c-8dfc-5809b941593a.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/33454514/135903552-00a05907-f6d7-4362-9a96-4039a45be86f.png" alt="image"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;([<span class="keyword">function</span>(<span class="params"><span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">&quot;console.lg(&#x27;hello source-map !&#x27;);&quot;</span> +</span><br><span class="line">      <span class="string">&quot;//# sourceURL=[module]\n//# &quot;</span> +</span><br><span class="line">      <span class="string">&quot;sourceMappingURL=data:application/json;&quot;</span> +</span><br><span class="line">      <span class="string">&quot;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJz&quot;</span> +</span><br><span class="line">      <span class="string">&quot;b3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2luZG&quot;</span> +</span><br><span class="line">      <span class="string">&quot;V4Mi5qcz9mNmJjIl0sIm5hbWVzIjpbImNvbnNvbGUiL&quot;</span> +</span><br><span class="line">      <span class="string">&quot;CJsZyJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0F&quot;</span> +</span><br><span class="line">      <span class="string">&quot;BQ0MsRUFBUixDQUFXLG9CQUFYIiwiZmlsZSI6IjAua&quot;</span> +</span><br><span class="line">      <span class="string">&quot;nMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmx&quot;</span> +</span><br><span class="line">      <span class="string">&quot;nKCdoZWxsbyBzb3VyY2UtbWFwICEnKSJdLCJzb3VyY2&quot;</span> +</span><br><span class="line">      <span class="string">&quot;VSb290IjoiIn0=\n//&quot;</span> +</span><br><span class="line">      <span class="string">&quot;# sourceURL=webpack-internal:///0\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="inline-source-map"><a href="#inline-source-map" class="headerlink" title="inline-source-map"></a>inline-source-map</h2><p>映射文件以 <code>base64</code> 格式编码，加在 <code>bundle</code> 文件最后，不产生独立的 <code>map</code> 文件。</p>
<p>加入 <code>map</code> 文件后可以明显的看到包体积变大了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;([<span class="keyword">function</span>(<span class="params">e, t</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">lg</span>(<span class="string">&quot;hello source-map !&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// # sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3Vy...</span></span><br><span class="line"><span class="comment">// base64编码</span></span><br></pre></td></tr></table></figure>

<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><ol>
<li>source-map</li>
</ol>
<ul>
<li>大而全，啥都有，会让 webpack 构建时间变长，看情况使用。</li>
</ul>
<ol start="2">
<li>cheap-module-eval-source-map </li>
</ol>
<ul>
<li>这个一般是开发环境（dev）推荐使用，在构建速度报错提醒上做了比较好的均衡。</li>
</ul>
<ol start="3">
<li>cheap-module-source-map</li>
</ol>
<ul>
<li>一般来说，生产环境是不配 <code>source-map</code> 的，如果想捕捉线上的代码报错，我们可以用这个</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
        <category>八股文</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文（一）—— 计算机网络</title>
    <url>/2021/09/22/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />
 
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628084581427-ad52128d-5d7c-4304-8fb3-8f8c6b59dc15.png"></p>
<ul>
<li>Physical, Data Link, Network, Transport, Application</li>
<li>应用层：常见协议：<ul>
<li>FTP(21端口)：文件传输协议</li>
<li>SSH(22端口)：远程登陆</li>
<li>TELNET(23端口)：远程登录</li>
<li>SMTP(25端口)：发送邮件</li>
<li>POP3(110端口)：接收邮件</li>
<li>HTTP(80端口)：超文本传输协议</li>
<li>DNS(53端口)：运行在UDP上，域名解析服务</li>
</ul>
</li>
<li>传输层：TCP/UDP</li>
<li>网络层：IP、ARP、NAT、RIP…</li>
<li>路由器网络层，根据IP地址进行寻址；</li>
</ul>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"></a></p>
<h1 id="传输层：TCP和UDP"><a href="#传输层：TCP和UDP" class="headerlink" title="传输层：TCP和UDP"></a>传输层：TCP和UDP</h1><h3 id="什么是三次握手-three-way-handshake-？"><a href="#什么是三次握手-three-way-handshake-？" class="headerlink" title="什么是三次握手 (three-way handshake)？"></a>什么是三次握手 (three-way handshake)？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083612400-05353867-b677-449d-bc87-378dc2ac5fbd.png"></p>
<ul>
<li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li>
<li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li>
<li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li>
</ul>
<h5 id="TCP建立连接可以两次握手吗？为什么"><a href="#TCP建立连接可以两次握手吗？为什么" class="headerlink" title="TCP建立连接可以两次握手吗？为什么?"></a>TCP建立连接可以两次握手吗？为什么?</h5><p>不可以。有两个原因：<br>首先，可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p>
<blockquote>
<p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p>
</blockquote>
<p>其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p>
<h5 id="可以采用四次握手吗？为什么？"><a href="#可以采用四次握手吗？为什么？" class="headerlink" title="可以采用四次握手吗？为什么？"></a>可以采用四次握手吗？为什么？</h5><p>可以。但是会降低传输的效率。<br>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p>
<h5 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h5><p>Server端：<br>由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。<br>Client端，两种情况：</p>
<ol>
<li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态 </li>
<li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</li>
</ol>
<h5 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h5><p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h5 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h5><p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p>
<h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083644967-a1117a3a-ad00-494a-bdf5-f357adfef3b9.png"></p>
<ul>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li>
</ul>
<h5 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p>
<h5 id="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h5><p>客户端没有收到ACK确认，会重新发送FIN请求。</p>
<h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h5><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。<br>MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h3 id="TCP如何实现流量控制？"><a href="#TCP如何实现流量控制？" class="headerlink" title="TCP如何实现流量控制？"></a>TCP如何实现流量控制？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083671501-2d938176-eced-4414-b6aa-fbc32d323ae9.png"></p>
<p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>
<p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1431305/1628083685654-29996960-ed15-47f4-99bf-246b8ac30214.gif"></p>
<h5 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h5><p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p>
<h3 id="TCP的拥塞控制是怎么实现的？"><a href="#TCP的拥塞控制是怎么实现的？" class="headerlink" title="TCP的拥塞控制是怎么实现的？"></a>TCP的拥塞控制是怎么实现的？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083709929-6e2bfba1-63ca-4742-a80a-256a93b0f159.png"></p>
<p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p>
<ol>
<li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083774060-71278d40-0b39-4e15-9dd1-22534e2c90d8.png"></li>
</ol>
<ol start="2">
<li>拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.</li>
</ol>
<blockquote>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p>
</blockquote>
<ol start="3">
<li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628083866222-2e727029-b6f2-495e-97f2-e4b7b49cd16e.png"></p>
<ol start="4">
<li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。<h3 id="TCP如何最大利用带宽？"><a href="#TCP如何最大利用带宽？" class="headerlink" title="TCP如何最大利用带宽？"></a>TCP如何最大利用带宽？</h3>TCP速率受到三个因素影响</li>
</ol>
<ul>
<li>窗口：即滑动窗口大小，见<a href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP如何实现流量控制？</a></li>
<li>带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。</li>
<li>RTT：即Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则任务数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。</li>
</ul>
<p>带宽时延乘积=带宽*RTT，实际上等于发送端到接收端单向通道的数据容积的两倍，这里单向通道的数据容积可以这样来理解，单向通道看成是一条单行道马路，带宽就是马路的车道数，路上跑的汽车就是数据（不过这里所有汽车的速率都是一样的，且不会有人想超车，大家齐头并进），那么单向通道的数据容积就是这条单行道上摆满车，一共可以摆多少辆。带宽就是马路的车道数，带宽数乘以单向通道的数据容积就是路面上所能容纳的全部数据量。当路面上已经摆满的时候，就不能再往里面放了。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628084389045-9ba4652e-2456-424e-b530-bd95b496004d.png"></p>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol>
<li>TCP是面向连接的，UDP是无连接的；</li>
<li>UDP发送数据之前不需要建立连接</li>
<li>TCP是可靠的，UDP不可靠； </li>
<li>UDP接收方收到报文后，不需要给出任何确认</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li>TCP是面向字节流的，UDP是面向报文的； </li>
<li>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</li>
<li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li>
<li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li>UDP 的主机不需要维持复杂的连接状态表</li>
</ol>
<h5 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h5><h5 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h5><p>注：<strong>http 3.0 使用udp实现</strong><br><a href="https://zh.wikipedia.org/wiki/HTTP/3">https://zh.wikipedia.org/wiki/HTTP/3</a></p>
<h5 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h5><p>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）<br>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；<br>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628084520127-fb51536c-1fee-4fa4-a450-684dab556f9e.png#height=494&id=HncLV&originHeight=659&originWidth=769&originalType=binary&ratio=1&status=done&style=none&width=577"></p>
<h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><ol>
<li>数据包校验</li>
<li>对失序数据包重新排序（TCP报文具有序列号）</li>
<li>丢弃重复数据</li>
<li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li>
<li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li>
<li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出<h1 id="应用层：HTTP和HTTPS"><a href="#应用层：HTTP和HTTPS" class="headerlink" title="应用层：HTTP和HTTPS"></a>应用层：HTTP和HTTPS</h1></li>
</ol>
<h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol>
<li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li>
<li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li>
<li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li>
<li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li>
</ol>
<h5 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h5><ol>
<li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>
<li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>
<li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>
<li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>
<li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>
<li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>
</ol>
<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p>
<h5 id="输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？"><a href="#输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？" class="headerlink" title="输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？"></a>输入 <a href="http://www.baidu.com,怎么变成/">www.baidu.com，怎么变成</a> <a href="https://www.baidu.com/">https://www.baidu.com</a> 的，怎么确定用HTTP还是HTTPS？</h5><p><a href="https://www.sohu.com/a/136637876_487516">你访问的网站是如何自动切换到 HTTPS 的？</a><br>一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。<br>解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。</p>
<h5 id="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"><a href="#HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？" class="headerlink" title="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"></a>HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？</h5><h5 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h5><ul>
<li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li>
<li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li>
<li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</li>
</ul>
<h5 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h5><ul>
<li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li>
<li>摘要算法:MD5、SHA</li>
</ul>
<h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol>
<li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li>
<li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li>
<li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li>
<li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li>
<li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li>
<li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制</li>
</ol>
<h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案<br>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p>
<h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol>
<li>2xx状态码：操作成功。200 OK</li>
<li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li>
<li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li>
<li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li>
</ol>
<h3 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p>
<p>（PS：RIP是应用层协议：<a href="https://www.zhihu.com/question/19645407">https://www.zhihu.com/question/19645407</a>）</p>
<ul>
<li>实现简单，开销小</li>
<li>随着网络规模扩大开销也会增大；</li>
<li>最大距离为15，限制了网络的规模；</li>
<li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器</li>
<li>交换机数据链路层，根据MAC地址进行寻址</li>
</ul>
<h1 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h1><h3 id="IP地址的分类？"><a href="#IP地址的分类？" class="headerlink" title="IP地址的分类？"></a>IP地址的分类？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628084593202-102c8a14-99c6-463c-8bde-866b86d19613.png"></p>
<p>路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。</p>
<h3 id="什么叫划分子网？"><a href="#什么叫划分子网？" class="headerlink" title="什么叫划分子网？"></a>什么叫划分子网？</h3><p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p>
<h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p>
<p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>
<h3 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h3><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>
<p>文章内容搬运自本人<a href="https://www.yuque.com/docs/share/5b2ba306-5030-4cff-8c82-19ecb35b4f40">语雀</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>八股文</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文（三）—— 数据库</title>
    <url>/2021/09/22/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h3 id="事务的概念和特性？"><a href="#事务的概念和特性？" class="headerlink" title="事务的概念和特性？"></a>事务的概念和特性？</h3><p>概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束<br>特性（ACID）：</p>
<ul>
<li><strong>原子性</strong>（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；</li>
<li><strong>一致性</strong>（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；</li>
<li><strong>隔离性</strong>（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；</li>
<li><strong>持久性</strong>（Durability）：一旦事务提交成功，对数据的修改是永久性的</li>
</ul>
<h3 id="会出现哪些并发一致性问题？"><a href="#会出现哪些并发一致性问题？" class="headerlink" title="会出现哪些并发一致性问题？"></a>会出现哪些并发一致性问题？</h3><ul>
<li><strong>丢失修改</strong>：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</li>
<li><strong>脏读</strong>（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；</li>
<li><strong>不可重复读</strong>（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对<strong>update</strong>操作）；</li>
<li><strong>幻读</strong>（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对<strong>insert/delete</strong>操作）</li>
</ul>
<h3 id="数据库的四种隔离级别？"><a href="#数据库的四种隔离级别？" class="headerlink" title="数据库的四种隔离级别？"></a>数据库的四种隔离级别？</h3><ul>
<li><strong>未提交读</strong>（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；</li>
<li><strong>提交读</strong>（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；</li>
<li><strong>可重复读</strong>（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；</li>
<li><strong>可串行化</strong>（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。</li>
</ul>
<h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><ul>
<li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于<strong>数据更新比较频繁</strong>的场景；</li>
<li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于<strong>读多写少</strong>的场景。乐观锁的实现方式有：<ul>
<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
<li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li>
</ul>
</li>
</ul>
<h3 id="常见的封锁类型？"><a href="#常见的封锁类型？" class="headerlink" title="常见的封锁类型？"></a>常见的封锁类型？</h3><p>意向锁是 InnoDB 自动加的， 不需用户干预。<br>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；<br>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。<br>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</p>
<ul>
<li><strong>排它锁</strong>（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；</li>
<li><strong>共享锁</strong>（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁</li>
<li><strong>意向锁</strong>（Intention Locks）：<ul>
<li>一个事务在获得某个<strong>数据行</strong>对象的 S 锁之前，必须先获得<strong>整个表</strong>的 IS 锁或更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</li>
<li>IS/IX 锁之间都是兼容的；</li>
<li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了</li>
</ul>
</li>
</ul>
<p>锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性</p>
<p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。<br>封锁粒度小：</p>
<ul>
<li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高；</li>
<li>坏处：<strong>系统开销</strong>大（加锁、释放锁、检查锁的状态都需要消耗资源）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="什么是三级封锁协议？"><a href="#什么是三级封锁协议？" class="headerlink" title="什么是三级封锁协议？"></a>什么是三级封锁协议？</h3><ul>
<li>一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；</li>
<li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；</li>
<li>三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）</li>
</ul>
<h3 id="什么是两段锁协议？"><a href="#什么是两段锁协议？" class="headerlink" title="什么是两段锁协议？"></a>什么是两段锁协议？</h3><p>事务必须严格分为两个阶段对数据进行<strong>加锁和解锁</strong>的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。</p>
<p><strong>可串行化调度</strong>是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。</p>
<h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储<strong>创建版本号</strong>和<strong>删除版本号</strong>。</p>
<ul>
<li>创建版本号：创建一个数据行时的事务版本号（<strong>事务版本号</strong>：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；</li>
<li>删除版本号：删除操作时的事务版本号；</li>
<li>各种操作：<ul>
<li>插入操作时，记录创建版本号；</li>
<li>删除操作时，记录删除版本号；</li>
<li>更新操作时，先记录删除版本号，再新增一行记录创建版本号；</li>
<li>查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）</li>
</ul>
</li>
</ul>
<p>通过版本号减少了锁的争用，<strong>提高了系统性能</strong>；可以实现<strong>提交读</strong>和<strong>可重复读</strong>两种隔离级别，未提交读无需使用MVCC</p>
<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table ...;</span><br></pre></td></tr></table></figure>
<p>当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert;</span><br><span class="line">update;</span><br><span class="line">delete;</span><br></pre></td></tr></table></figure>

<h3 id="数据库的范式？"><a href="#数据库的范式？" class="headerlink" title="数据库的范式？"></a>数据库的范式？</h3><ul>
<li><p><strong>第一范式</strong>（1NF，Normal Form）：<strong>属性不应该是可分的</strong>。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话…如果将“移动电话”作为一个属性，就符合1NF；</p>
</li>
<li><p><strong>第二范式</strong> 2NF：每个非主属性<strong>完全依赖</strong>于主属性集（候选键集）；</p>
<ul>
<li>B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；</li>
<li>主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；</li>
<li>可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；<br>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>
</ul>
</li>
<li><p><strong>第三范式</strong> 3NF：在 2NF 的基础上，非主属性<strong>不传递依赖</strong>于主属性</p>
<ul>
<li>传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；</li>
<li>3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。<br>必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>
</ul>
</li>
<li><p>冗余数据：某些同样的数据多次出现（如学生姓名）；</p>
</li>
<li><p>修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；</p>
</li>
<li><p>删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；</p>
</li>
<li><p>插入异常：无法插入（插入一个还没有课程信息的学生）</p>
</li>
</ul>
<h3 id="列举几种表连接方式？"><a href="#列举几种表连接方式？" class="headerlink" title="列举几种表连接方式？"></a>列举几种表连接方式？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628085012977-cccccdf6-0f16-4343-8cd4-68631fb6b78a.png"></p>
<ul>
<li>内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集<ul>
<li>自然连接：只考虑属性相同的元组对；</li>
<li>等值连接：给定条件进行查询</li>
</ul>
</li>
</ul>
<ul>
<li>外连接（Outer Join）<ul>
<li>左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；</li>
<li>右连接：和左连接相反；</li>
<li>全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据</li>
</ul>
</li>
</ul>
<ul>
<li>交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）</li>
</ul>
<h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。<br>优点：</p>
<ul>
<li>预先编译，而不需要每次运行时编译，提高了数据库执行<strong>效率</strong>；</li>
<li>封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以<strong>减少网络通信量</strong>；</li>
<li>具有<strong>可复用性</strong>，减少了数据库开发的工作量；</li>
<li><strong>安全性高</strong>，可以让没有权限的用户通过存储过程间接操作数据库；</li>
<li>更<strong>易于维护</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>可移植性差</strong>，存储过程将应用程序绑定到了数据库上；</li>
<li><strong>开发调试复杂</strong>：没有好的IDE；</li>
<li><strong>修改复杂</strong>，需要重新编译，有时还需要更新程序中的代码以更新调用</li>
</ul>
<h3 id="Drop-Delete-Truncate的区别？"><a href="#Drop-Delete-Truncate的区别？" class="headerlink" title="Drop/Delete/Truncate的区别？"></a>Drop/Delete/Truncate的区别？</h3><ul>
<li><strong>Delete</strong>用来删除表的全部或者<strong>部分数据</strong>，执行delete之后，用户<strong>需要提交</strong>之后才会执行，会触发表上的DELETE<strong>触发器</strong>（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；</li>
<li><strong>Truncate</strong>删除表中的所有数据，这个操作<strong>不能回滚</strong>，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；</li>
<li><strong>Drop</strong>命令从数据库中<strong>删除表</strong>，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；</li>
</ul>
<p>触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于<strong>保证数据完整性</strong>（比如可以检验或转换数据）。</p>
<p>约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。</p>
<h3 id="什么是视图？什么是游标？"><a href="#什么是视图？什么是游标？" class="headerlink" title="什么是视图？什么是游标？"></a>什么是视图？什么是游标？</h3><ul>
<li>视图：从数据库的基本表中通过查询选取出来的数据组成的<strong>虚拟表</strong>（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：<ul>
<li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>；</li>
<li><strong>简化</strong>复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；</li>
</ul>
</li>
<li>游标（Cursor）：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="数据库索引的实现原理（B-树）"><a href="#数据库索引的实现原理（B-树）" class="headerlink" title="数据库索引的实现原理（B+树）"></a>数据库索引的实现原理（B+树）</h3></li>
</ul>
<p>见<a href="https://github.com/wolverinn/Iridescent/blob/master/Data%20Structure.md#b%E6%A0%91">数据结构部分：B树，B+树</a></p>
<h5 id="使用B树和B-树的比较"><a href="#使用B树和B-树的比较" class="headerlink" title="使用B树和B+树的比较"></a>使用B树和B+树的比较</h5><p>InnoDB的索引使用的是B+树实现，B+树对比B树的好处：</p>
<ul>
<li>IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；</li>
<li>范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；</li>
<li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</li>
</ul>
<h5 id="使用B树索引和哈希索引的比较"><a href="#使用B树索引和哈希索引的比较" class="headerlink" title="使用B树索引和哈希索引的比较"></a>使用B树索引和哈希索引的比较</h5><p>哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。</p>
<h3 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h3><ul>
<li>大大加快了数据的<strong>检索速度</strong>；</li>
<li>可以显著减少查询中<strong>分组和排序</strong>的时间；</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
<li>将随机 I/O 变为<strong>顺序 I/O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>
</ul>
<p>缺点：建立和维护索引耗费时间空间，更新索引很慢。</p>
<h3 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h3><ul>
<li>以“%(表示任意0个或多个字符)”开头的LIKE语句；</li>
<li>OR语句前后没有同时使用索引；</li>
<li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li>
<li>对于多列索引，必须满足 <strong>最左匹配原则</strong>/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；</li>
<li>如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）</li>
</ul>
<h3 id="在哪些地方适合创建索引？"><a href="#在哪些地方适合创建索引？" class="headerlink" title="在哪些地方适合创建索引？"></a>在哪些地方适合创建索引？</h3><ul>
<li>某列经常作为最大最小值；</li>
<li>经常被查询的字段；</li>
<li>经常用作表连接的字段；</li>
<li>经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段</li>
</ul>
<h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><ul>
<li>只应建立在<strong>小字段</strong>上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；</li>
<li>建立索引的字段应该<strong>非空</strong>，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；</li>
<li>选择<strong>数据密度大</strong>（唯一值占总数的百分比很大）的字段作索引</li>
</ul>
<h3 id="索引的分类？"><a href="#索引的分类？" class="headerlink" title="索引的分类？"></a>索引的分类？</h3><ul>
<li>普通索引</li>
<li>唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；</li>
<li>主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；</li>
<li>单列索引和多列索引/复合索引（Composite）：索引的列数；</li>
<li>覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；</li>
<li>聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；</li>
<li>分区索引（？）</li>
<li>虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用</li>
</ul>
<h3 id="MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？"><a href="#MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？" class="headerlink" title="MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？"></a>MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？</h3><ul>
<li><p>InnoDB<strong>支持事务</strong>，可以进行Commit和Rollback；</p>
</li>
<li><p>MyISAM 只支持表级锁，而 InnoDB 还<strong>支持行级锁</strong>，提高了并发操作的性能；</p>
</li>
<li><p>InnoDB <strong>支持外键</strong>；</p>
</li>
<li><p>MyISAM <strong>崩溃</strong>后发生损坏的概率比 InnoDB 高很多，而且<strong>恢复的速度</strong>也更慢；</p>
</li>
<li><p>MyISAM 支持<strong>压缩</strong>表和空间数据索引，InnoDB需要更多的内存和存储；</p>
</li>
<li><p>InnoDB 支持在线<strong>热备份</strong></p>
</li>
<li><p><strong>MyISAM</strong> 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；</p>
</li>
<li><p><strong>InnoDB</strong> 支持事务，并发情况下有很好的性能，基本可以替代MyISAM</p>
</li>
<li><p>热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错</p>
</li>
<li><p>冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单</p>
</li>
</ul>
<p>更详细的可以参考：<a href="https://imageslr.github.io/2020/db-engine.html">MySQL 数据库的存储引擎与适用场景 - Images</a></p>
<h3 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h3><blockquote>
<p>分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL</p>
</blockquote>
<blockquote>
<p>使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、<strong>哪些索引被实际使用</strong>、表之间的引用以及<strong>被扫描的行数</strong>等问题；</p>
</blockquote>
<ul>
<li>应尽量避免在 where 子句中使用<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；</li>
<li>只返回必要的列：最好不要使用 SELECT * 语句；</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据；</li>
<li>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；</li>
<li>减少锁竞争</li>
</ul>
</li>
</ul>
<p>注意会引起索引失效的情况，以及在适合的地方建立索引</p>
<ul>
<li><p>设计表时遵循<strong>三大范式</strong>；</p>
</li>
<li><p>选择合适的<strong>数据类型</strong>：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；</p>
</li>
<li><p>表的<strong>水平切分</strong>（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；</p>
</li>
<li><p>表的<strong>垂直切分</strong>：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单</p>
</li>
<li><p>操作系统：增加TCP支持的队列数；</p>
</li>
<li><p>MySQL配置文件优化：缓存池大小和个数设置</p>
</li>
<li><p>磁盘性能：固态硬盘；</p>
</li>
<li><p>CPU：多核且高频；</p>
</li>
<li><p>内存：增大内存</p>
</li>
</ul>
<h3 id="什么是主从复制？实现原理是什么？"><a href="#什么是主从复制？实现原理是什么？" class="headerlink" title="什么是主从复制？实现原理是什么？"></a>什么是主从复制？实现原理是什么？</h3><p>主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。</p>
<p>实现原理：</p>
<ul>
<li>主服务器 <strong>binary log dump 线程</strong>：将主服务器中的数据更改（增删改）日志写入 Binary log 中；</li>
<li>从服务器 <strong>I/O 线程</strong>：负责从主服务器读取binary log，并写入本地的 Relay log；</li>
<li>从服务器 <strong>SQL 线程</strong>：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性</li>
</ul>
<h5 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h5><ul>
<li>读写分离：主服务器负责写，从服务器负责读<ul>
<li>缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性</li>
</ul>
</li>
<li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li>
<li>降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能</li>
</ul>
<h1 id="NoSQL-Redis"><a href="#NoSQL-Redis" class="headerlink" title="NoSQL/Redis"></a>NoSQL/Redis</h1><ul>
<li><a href="https://blog.csdn.net/Butterfly_resting/article/details/89668661">几率大的Redis面试题（含答案） - CSDN</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md">CyC2018</a></li>
<li><a href="https://www.jianshu.com/p/65765dd10671">Redis面试题总结 - 简书</a></li>
<li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">Redis常见面试题 - 博客园</a></li>
<li><a href="https://github.com/0voice/interview_internal_reference#10">0voice/interview_internal_reference</a></li>
</ul>
<p>文章内容搬运自本人<a href="https://www.yuque.com/docs/share/c6097254-4f08-4d0f-b9c0-550c9274e6be">语雀</a></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>数据库</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试八股文（二）—— 操作系统</title>
    <url>/2021/09/22/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h3 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h3><ul>
<li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li>
<li>线程依赖于进程而存在，一个进程至少有一个线程；</li>
<li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>
<li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</li>
<li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>
<li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li>
<li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<p>进程操作代码实现，可以参考：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064">多进程 - 廖雪峰的官方网站</a></p>
<h5 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h5><ul>
<li>进程代码段</li>
<li>进程的公有数据（全局变量、静态变量…）</li>
<li>进程打开的文件描述符</li>
<li>进程的当前目录</li>
<li>信号处理器/信号处理函数：对收到的信号的处理方式</li>
<li>进程ID与进程组ID</li>
</ul>
<h5 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h5><ul>
<li>线程ID</li>
<li>一组寄存器的值</li>
<li>线程自身的栈（堆是共享的）</li>
<li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
<li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li>
</ul>
<h3 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h3><ol>
<li>管道(Pipe)</li>
</ol>
<ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li>
<li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)</li>
</ul>
<ol start="2">
<li>命名管道</li>
<li>消息队列</li>
<li>信号(Signal)</li>
<li>共享内存</li>
<li>信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态</li>
<li>套接字(Socket)</li>
</ol>
<p>更详细的可以参考：</p>
<ul>
<li><a href="https://imageslr.github.io/2020/02/26/ipc.html">https://imageslr.github.io/2020/02/26/ipc.html</a></li>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></li>
</ul>
<h3 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h3><blockquote>
<p>进程的同步是目的，而进程间通信是实现进程同步的手段</p>
</blockquote>
<p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。<br>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。（<strong>HOARE管程</strong>）<br>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（<strong>HOARE管程</strong>）<br><strong>MESA管程</strong>：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换</p>
<blockquote>
<p>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述 </span></span><br><span class="line"><span class="comment">// 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量</span></span><br><span class="line">semaphore full = <span class="number">0</span>, empty = n, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">   	  P(empty);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 生产者进行生产</span></span><br><span class="line">   	</span><br><span class="line">   	  V(mutex);</span><br><span class="line">   	  V(full);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	  P(full);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 消费者进行消费</span></span><br><span class="line"></span><br><span class="line">	  V(mutex);</span><br><span class="line">	  V(empty);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5  <span class="comment">// number of philosopher</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1)%N <span class="comment">// number of i&#x27;s left neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1)%N <span class="comment">// number of i&#x27;s right neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N]; <span class="comment">// array to keep track of everyone&#x27;s state</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// mutual exclusion of critical region</span></span><br><span class="line">semaphore s[N]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		think();</span><br><span class="line">		take_forks(i);</span><br><span class="line">		eat();</span><br><span class="line">		put_forks(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = HUNGRY; <span class="comment">// record that i is hungry</span></span><br><span class="line">	test_forks(i); <span class="comment">// try to acquire two forks</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">	down(&amp;s[i]); <span class="comment">// block if forks are not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = THINKING; <span class="comment">// record that has finished eating</span></span><br><span class="line">	test_forks(LEFT); <span class="comment">// see if left neighbor can now eat</span></span><br><span class="line">	test_forks(RIGHT); <span class="comment">// see if right neighbor can now eat</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_forks</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) &#123;</span><br><span class="line">		state[i] = EATING;</span><br><span class="line">		up(&amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="临界区的概念？"><a href="#临界区的概念？" class="headerlink" title="临界区的概念？"></a>临界区的概念？</h5><p>各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段</p>
<h5 id="同步与互斥的概念？"><a href="#同步与互斥的概念？" class="headerlink" title="同步与互斥的概念？"></a>同步与互斥的概念？</h5><ul>
<li>同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区</li>
</ul>
<h5 id="并发、并行、异步的区别？"><a href="#并发、并行、异步的区别？" class="headerlink" title="并发、并行、异步的区别？"></a>并发、并行、异步的区别？</h5><p>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；<br>多线程：并发运行的一段代码。是实现异步的手段<br>并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的<br>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事</p>
<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1431305/1628085394606-49204b73-729e-4f57-97bc-d43ad01ec54b.png"></p>
<ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>
</ul>
<h3 id="进程调度策略有哪些？"><a href="#进程调度策略有哪些？" class="headerlink" title="进程调度策略有哪些？"></a>进程调度策略有哪些？</h3><ol>
<li><strong>批处理系统</strong>：<br>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；<br>对短进程不利，对IO密集型进程不利。</li>
</ol>
<p>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；<br>对短进程提供好的响应时间，对长进程不利。</p>
<p>按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；<br>可能导致饥饿问题，对长进程不利。</p>
<p>响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</p>
<ol start="2">
<li><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>
</ol>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；<br>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</p>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。<br>抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p>
<h5 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h5><p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。<br>解决方法：</p>
<ul>
<li>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li>
<li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</li>
</ul>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p>
<p>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</p>
<p>以下情况不会产生僵尸进程：</p>
<ul>
<li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li>
<li>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入<code>WNOHANG</code>(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li>
<li>子进程结束时，系统会产生<code>SIGCHLD</code>(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>
<li>也可以用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号，那么子进程结束后，内核会进行回收。</li>
</ul>
<h5 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h5><p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</p>
<h3 id="线程同步有哪些方式？"><a href="#线程同步有哪些方式？" class="headerlink" title="线程同步有哪些方式？"></a>线程同步有哪些方式？</h3><blockquote>
<p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p>
</blockquote>
<ul>
<li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
<li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过<code>ReleaseSemaphore</code>函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；</li>
<li><strong>事件</strong> Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li>
<li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<h5 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h5><p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</p>
<h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h5 id="协程多与线程进行比较？"><a href="#协程多与线程进行比较？" class="headerlink" title="协程多与线程进行比较？"></a>协程多与线程进行比较？</h5><ol>
<li>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li>
<li>线程进程都是同步机制，而协程则是异步</li>
<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>
</ol>
<h3 id="进程的异常控制流：陷阱、中断、异常和信号"><a href="#进程的异常控制流：陷阱、中断、异常和信号" class="headerlink" title="进程的异常控制流：陷阱、中断、异常和信号"></a>进程的异常控制流：陷阱、中断、异常和信号</h3><p>陷阱是<strong>有意</strong>造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现<strong>系统调用</strong>。比如，进程可以执行 <code>syscall n</code> 指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，<strong>陷入</strong>到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行<strong>下一条指令</strong>。</p>
<p>中断由处理器<strong>外部</strong>的<strong>硬件</strong>产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p>
<p>异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的<strong>错误情况</strong>，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为<strong>“故障”</strong>。</p>
<p>信号是一种<strong>更高层的</strong>软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来<strong>通知进程</strong>发生了某种系统事件。</p>
<p>更详细的可以参考：<a href="https://imageslr.github.io/2020/07/09/trap-interrupt-exception.html">https://imageslr.github.io/2020/07/09/trap-interrupt-exception.html</a></p>
<h3 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h3><p>IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。</p>
<p>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。</p>
<ul>
<li><code>select</code>：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong>开销大</strong>），由内核根据就绪状态修改该集合的内容。（缺点2）<strong>集合大小有限制</strong>，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；</li>
<li><code>poll</code>：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；</li>
<li><code>epoll</code>：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</li>
</ul>
<p>总结，区别主要在于：</p>
<ul>
<li>一个线程/进程所能打开的最大连接数</li>
<li>文件描述符传递方式（是否复制）</li>
<li>水平触发 or 边缘触发</li>
<li>查询就绪的描述符时的效率（是否轮询）</li>
</ul>
<p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
<h5 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h5><ul>
<li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>
<li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li>
<li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>
<li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</li>
</ul>
<h5 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h5><ul>
<li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
<li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
<li>IO多路复用</li>
<li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</li>
</ul>
<h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h5 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h5><ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
<li>封装性：用户程序不需要实现更加底层的代码；</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</li>
</ul>
<h5 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h5><ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
<li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>
<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h3><p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>基本思想是破坏形成死锁的四个必要条件：</p>
<ul>
<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>
<li>破坏占有并等待条件：<ul>
<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>
<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>
<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；</li>
</ul>
</li>
<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li>
<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</li>
</ul>
<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>
<blockquote>
<p>银行家算法<br>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。<br>死锁解除的方法：</p>
</blockquote>
<ul>
<li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>
<li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li>
<li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ul>
<p>区别：</p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li>分段便于信息的保护和共享；分页的共享收到限制；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<p>虚拟内存的实现方式、页表/多级页表、缺页中断、不同的页面淘汰算法：<a href="https://imageslr.github.io/2020/07/08/tech-interview.html#virtual-memory">答案</a>。</p>
<h5 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h5><p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
<h3 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><p><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</p>
</li>
<li><p><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</p>
</li>
<li><p><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</p>
</li>
<li><p><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</p>
</li>
<li><p><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</p>
</li>
<li><p><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
</li>
<li><p><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面</p>
</li>
<li><p>时间上：最近被访问的页在不久的将来还会被访问；</p>
</li>
<li><p>空间上：内存中被访问的页周围的页也很可能被访问。</p>
</li>
</ul>
<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</li>
</ul>
<h3 id="缓冲区溢出问题"><a href="#缓冲区溢出问题" class="headerlink" title="缓冲区溢出问题"></a>缓冲区溢出问题</h3><p>防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。</p>
<ul>
<li>随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。</li>
<li>栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个<strong>随机产生的</strong>特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</li>
<li>限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。</li>
</ul>
<p>更详细的可以参考：<a href="https://imageslr.github.io/2020/07/08/tech-interview.html#stackoverflow">https://imageslr.github.io/2020/07/08/tech-interview.html#stackoverflow</a></p>
<h1 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h1><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</ul>
<h1 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a><a href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC</a></h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78304294">面试/笔试第二弹 —— 操作系统面试问题集锦 - CSDN博客</a></li>
<li><a href="https://segmentfault.com/a/1190000018970361">线程同步与并发 - - SegmentFault</a></li>
<li><a href="http://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc">彻底搞懂epoll高效运行的原理</a></li>
<li><a href="https://www.cnblogs.com/lirong21/p/4213028.html">用户态与内核态的切换</a></li>
</ul>
<p>文章内容搬运自本人<a href="https://www.yuque.com/docs/share/4137d8f0-4b2e-4a18-a5a3-7a01239affcc">语雀</a></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2021/09/21/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一条SQL查询语句是如何执行的"><a href="#一条SQL查询语句是如何执行的" class="headerlink" title="一条SQL查询语句是如何执行的"></a>一条SQL查询语句是如何执行的</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/20190410210326412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=Mnrxq&originHeight=798&originWidth=1086&originalType=binary&ratio=1&status=done&style=none"></p>
<blockquote>
<p>大体来说，MySQL可以分为<code>Server</code>层和<code>存储引擎</code>层两部分</p>
</blockquote>
<ul>
<li><code>Server</code>层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>
<li><code>存储引擎层</code>负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</li>
<li>不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分</li>
<li></li>
</ul>
<p><strong>连接器</strong></p>
<ul>
<li>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在<code>show processlist</code>命令中看到它。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数<code>wait_timeout</code>控制的，默认值是<code>8</code>小时。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li>
</ul>
<p><strong>查询缓存</strong></p>
<ul>
<li>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</li>
<li>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</li>
<li>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。</li>
</ul>
<blockquote>
<p>大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p>
</blockquote>
<p><strong>分析器</strong></p>
<ul>
<li>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。分析器先会做<code>“词法分析”</code>,词法分析完后就要做<code>“语法分析”</code>。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒</li>
</ul>
<p><strong>优化器</strong></p>
<ul>
<li>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</li>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li>
</ul>
<blockquote>
<p>比如你执行下面这样的语句，这个语句是执行两个表的join：<br><code>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</code><br>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。<br>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。<br>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
</blockquote>
<p><strong>执行器</strong></p>
<ul>
<li>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</li>
<li>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误</li>
<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
</ul>
<blockquote>
<p><code>mysql&gt; select * from T where ID=10;</code><br>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：<br>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；<br>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。<br>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
</blockquote>
<ul>
<li>至此，这个整个语句就执行完成了。一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</li>
</ul>
<h3 id="一条SQL更新语句是如何执行的"><a href="#一条SQL更新语句是如何执行的" class="headerlink" title="一条SQL更新语句是如何执行的"></a>一条SQL更新语句是如何执行的</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>与查询流程不一样的是，更新流程还涉及两个重要的日志模块 <code>redo log</code>（重做日志）和 <code>binlog</code>（归档日志）</li>
<li>每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志</code>，<code>再写磁盘</code></li>
<li>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。</li>
<li>同时，<code>InnoDB</code>引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。但是<code>InnoDB</code>的<code>redo log</code>是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB,总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写。</li>
<li>在进行<code>redo log</code>写入时，有两个重要参数的write pos(当前记录的位置),<code>checkpoint</code>是当前要擦除的位置<br><img src="https://img-blog.csdnimg.cn/20190410230340406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=evnl5&originHeight=272&originWidth=884&originalType=binary&ratio=1&status=done&style=none"></li>
<li>一边写一边后移，写到第3号文件末尾后就回到0号文件开头,checkpoint也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间还空着的部分，可以用来记录新的操作。</li>
<li>如果<code>write pos</code>追上<code>checkpoin</code>，表示<code>redo log</code>满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</li>
<li>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe(崩溃安全()。</li>
<li>redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）</li>
<li>最开始MySQL里并没有<code>InnoDB引擎</code>。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</li>
</ul>
<blockquote>
<p><code>redo log是InnoDB引擎特有的</code>；binlog是MySQL的Server层实现的，所有引擎都可以使用。<br><code>redo log是物理日志</code>，记录的是“在某个数据页上做了什么修改”；<code>binlog是逻辑日志</code>，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。<br>r<code>edo log是循环写的</code>，<code>空间固定</code>会用完；<code>binlog是可以追加写入的</code>。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</blockquote>
<p><strong>执行器和InnoDB引擎在执行这个简单的update语句时的内部流程:</strong></p>
<ul>
<li>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
<li>redo log的写入拆成了两个步骤：prepare和commit，这就是<code>&quot;两阶段提交&quot;</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019041023325625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=tDmdi&originHeight=1522&originWidth=1142&originalType=binary&ratio=1&status=done&style=none"></p>
<blockquote>
<p><code>1 prepare阶段 2 写binlog 3 commit</code> , 当在<code>2之前崩溃时</code>,重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。<br><code>当在3之前崩溃</code>,重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。</li>
<li>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</li>
</ul>
<h3 id="事务隔离：为什么你改了我还看不见"><a href="#事务隔离：为什么你改了我还看不见" class="headerlink" title="事务隔离：为什么你改了我还看不见"></a>事务隔离：为什么你改了我还看不见</h3><ul>
<li>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的。MySQL默认的<code>MyISAM</code>引擎就不支持事务，这也是<code>MyISAM</code>被<code>InnoDB</code>取代的重要原因之一。</li>
<li>事务的特性：<code>ACID</code>即原子性、一致性、隔离性、持久性。多个事务同时执行的时候，就可能出现<code>脏读</code>，<code>不可重复读</code>，<code>幻读</code>，为了解决这些问题，就有了“<code>隔离级别</code>”的概念。但是隔离得越严实，效率就会越低</li>
<li>SQL标准的事务隔离级别包括：<code>读未提交</code>（read uncommitted）、<code>读提交</code>（read committed）、<code>可重复读</code>（repeatable read）和<code>串行化</code>（serializable ）</li>
</ul>
<blockquote>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。<br>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。<br>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化:对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p>
</blockquote>
<ul>
<li>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“<code>可重复读</code>”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在<code>“读提交”</code>隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。<code>“读未提交”</code>隔离级别下直接返回记录上的最新值，没有视图概念。<code>串行化</code>”隔离级别下直接用加锁的方式来避免并行访问</li>
<li>查看数据库的实物隔离级别：<code>show variables like &#39;%isolation%&#39;;</code></li>
<li>事务隔离的实现：在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</li>
</ul>
<p>假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（<code>MVCC</code>）<br><img src="https://img-blog.csdnimg.cn/20190411130916709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=AC58n&originHeight=407&originWidth=973&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的read-view的时候。</li>
<li>为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</li>
<li>事务启动方式：一、显式启动事务语句，<code>begin</code>或者<code>start transaction</code>,提交<code>commit</code>，回滚<code>rollback</code>；二、<code>set autocommit=0</code>，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行<code>commit</code>或<code>rollback</code>或断开连接。</li>
<li>建议使用方法一，如果考虑多一次交互问题，可以使用<code>commit work and chain</code>语法。在<code>autocommit=1</code>的情况下用<code>begin</code>显式启动事务，如果执行<code>commit</code>则提交事务。如果执行<code>commit work and chain</code>则提交事务并自动启动下一个事务</li>
</ul>
<h3 id="深入浅出索引（上）"><a href="#深入浅出索引（上）" class="headerlink" title="深入浅出索引（上）"></a>深入浅出索引（上）</h3><p><strong>索引的常见模型</strong></p>
<ul>
<li>索引的出现是为了提高查询效率，常见的三种索引模型分别是<code>哈希表</code>、<code>有序数组</code>和<code>搜索树</code></li>
<li><code>哈希表</code>：一种以<code>key-value</code> 存储数据的结构，哈希的思路是把值放在数组里，用一个哈希函数把<code>key</code>换算成一个确定的位置，然后把<code>value</code>放在数组的这个位置。哈希冲突的处理办法是使用<code>链表</code>。哈希表适用只有<code>等值查询</code>的场景</li>
<li><code>有序数组</code>：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))。查询效率高，更新效率低（涉及到移位）。在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎。</li>
<li>二叉搜索树：每个节点的左儿子小于父节点，右儿子大于父节点。查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。数据库存储大多不适用二叉树，因为树高过高，会适用N叉树</li>
</ul>
<p><strong>InnoDB 的索引模型</strong></p>
<ul>
<li><code>InnoDB</code>使用了<code>B+树</code>索引模型，所以数据都是存储在B+树中的。每一个索引在<code>InnoDB</code>里面对应一棵B+树。</li>
<li>索引类型分为<code>主键索引</code>和<code>非主键索引</code>。主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为<code>聚簇索引</code>。非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为<code>二级索引</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190411164702315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=GPjHM&originHeight=424&originWidth=1004&originalType=binary&ratio=1&status=done&style=none"></p>
<p><strong>主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是<code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是<code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为<code>回表</code>。</li>
<li>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询</li>
</ul>
<p><strong>索引维护</strong></p>
<ul>
<li><code>B+树</code>为了维护索引有序性，在插入新值的时候需要做必要的维护。涉及到数据的移动和数据页的增加和删减</li>
<li>一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做<code>页分裂</code>，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做<code>数据页合并</code>，合并的过程是分裂过程的<code>逆过程</code>。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</li>
</ul>
<blockquote>
<p><code>alter table T drop index k</code>;     alter table T add index(k);<br>要重建主键索引<br><code>alter table T drop primary key</code>;      <code>alter table T add primary key(id)</code>;<br>重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。<br>可以用这个语句代替 ： alter table T engine=InnoDB</p>
</blockquote>
<h3 id="深入浅出索引（下）"><a href="#深入浅出索引（下）" class="headerlink" title="深入浅出索引（下）"></a>深入浅出索引（下）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/20190411193509228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=iQfIH&originHeight=441&originWidth=989&originalType=binary&ratio=1&status=done&style=none"><br>如果我执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<p><strong>SQL查询语句的执行流程：</strong></p>
<ul>
<li>在k索引树上找到k=3的记录，取得 ID = 300；</li>
<li>再到ID索引树查到ID=300对应的R3；</li>
<li>在k索引树取下一个值k=5，取得ID=500；</li>
<li>再回到ID索引树查到ID=500对应的R4；</li>
<li>在k索引树取下一个值k=6，不满足条件，循环结束。</li>
<li>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录，回表了两次。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。</li>
</ul>
<p><strong>优化方式</strong></p>
<ul>
<li>sql语句修改为<code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为<code>覆盖索引</code>。</li>
<li>由于<code>覆盖索引</code>可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>覆盖索引</code>：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据</li>
<li><code>最左前缀</code>：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</li>
<li><code>联合索引</code>：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。</li>
<li>索引下推：<code>like &#39;hello%’and age &gt;10</code> 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age&lt;10的数据，再进行回表查询，减少回表率，提升检索速度</li>
</ul>
<h3 id="讲全局锁和表锁：给表加个字段怎么有这么多阻碍"><a href="#讲全局锁和表锁：给表加个字段怎么有这么多阻碍" class="headerlink" title="讲全局锁和表锁：给表加个字段怎么有这么多阻碍"></a>讲全局锁和表锁：给表加个字段怎么有这么多阻碍</h3><blockquote>
<p>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</p>
</blockquote>
<p><strong>全局锁</strong></p>
<ul>
<li>对整个数据库实例加锁。MySQL提供加全局读锁的方法：<code>Flush tables with read lock(FTWRL)</code>。这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句和更新类事务的提交语句等操作都会被阻塞。使用场景：<code>全库逻辑备份</code>。</li>
<li>风险是如果在主库备份，在备份期间不能更新，业务停摆。如果在从库备份，备份期间不能执行主库同步的binlog，导致主从延迟。官方自带的逻辑备份工具<code>mysqldump</code>，当mysqldump使用参数<code>--single-transaction</code>的时候，会启动一个事务，确保拿到一致性视图。而由于<code>MVCC</code>的支持，这个过程中数据是可以正常更新的。</li>
<li>一致性读是好，但是前提是引擎要支持这个隔离级别。如果要全库只读，为什么不使用<code>set global readonly=true</code>的方式？在有些系统中，<code>readonly</code>的值会被用来做其他逻辑，比如判断主备库。所以修改global变量的方式影响太大。</li>
<li>在异常处理机制上有差异。如果执行<code>FTWRL</code>命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为<code>readonly</code>之后，如果客户端发生异常，则数据库就会一直保持<code>readonly</code>状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p><strong>表级锁</strong></p>
<ul>
<li>MySQL里面表级锁有两种，一种是表锁，一种是元数据所(meta data lock,MDL)。表锁的语法是:l<code>ock tables ... read/write</code></li>
<li>可以用<code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。<code>lock tables</code>语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
<li>对于<code>InnoDB</code>这种支持<code>行锁</code>的引擎，一般不使用<code>lock tables</code>命令来控制并发，毕竟锁住整个表的影响面还是太大。</li>
<li>另一类表级的锁是<code>MDL</code>（metadata lock)。<code>MDL不需要显式使用</code>，在访问一个表的时候会被<code>自动加上</code>。MDL的作用是，<code>保证读写的正确性</code>。当对一个表做增删改查操作的时候，加<code>MDL读锁</code>；当要对表做结构变更操作的时候，加<code>MDL写锁</code>。<code>读锁之间不互斥</code>，因此你可以有多个线程同时对一张表增删改查。<code>读写锁之间、写锁之间是互斥的</code>，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
<li><code>MDL</code> 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</li>
</ul>
<p><strong>如何安全地给表加字段</strong></p>
<ul>
<li>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。首先我们要解决长事务，事务不提交，就会一直占着MDL锁。在MySQL的<code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做<code>DDL</code>变更的表刚好有<code>长事务</code>在执行，要考虑先暂停DDL，或者<code>kill</code>掉这个长事务。</li>
<li>如果你要变更的表是一个<code>热点表</code>，虽然数据量不大，但是上面的请求很频繁，这时候kill可能未必管用，因为新的请求马上就来了。比较理想的机制是，在<code>alter table</code>语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到<code>MDL写锁</code>最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。</li>
</ul>
<h3 id="讲行锁功过：怎么减少行锁对性能的影响"><a href="#讲行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="讲行锁功过：怎么减少行锁对性能的影响"></a>讲行锁功过：怎么减少行锁对性能的影响</h3><ul>
<li>MySQL的<code>行锁</code>是在引擎层由各个<code>引擎自己实现</code>的。但并不是所有的引擎都支持行锁，比<code>如MyISAM引擎就不支持行锁</code>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<code>InnoDB是支持行锁</code>的，这也是<code>MyISAM</code>被<code>InnoDB</code>替代的重要原因之一。</li>
<li><code>两阶段锁协议</code>：在<code>InnoDB</code>事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</li>
<li><code>死锁</code>：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190412161554856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=Enkur&originHeight=585&originWidth=948&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li><code>事务A</code>在等待<code>事务B</code>释放id=2的行锁，而<code>事务B在等待事务A</code>释放id=1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了<code>死锁状态</code></li>
</ul>
<p><strong>出现死锁以后，有两种策略：</strong></p>
<ul>
<li>一种策略是，<code>直接进入等待，直到超时</code>。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。在InnoDB中，默认值是<code>50s</code></li>
<li>另一种策略是，<code>发起死锁检测</code>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数<code>innodb_deadlock_detect设置为on</code>，表示开启这个逻辑。默认值本身就是on</li>
<li>正常情况下选择第二种策略，但是它也是有额外负担的，如果瞬间有大量线程请求会消耗消耗大量的CPU资源，但是每秒却执行不了几个事务，因为每次都要检测。</li>
</ul>
<p><strong>怎么解决由这种热点行更新导致的性能问题?</strong></p>
<ul>
<li>问题的症结在于，死锁检测要耗费大量的CPU资源</li>
<li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。 一般不建议采用</li>
<li>控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了。</li>
<li>将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</li>
<li><code>innodb行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</code></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果你要删除一个表里面的前10000行数据，有以下三种方法可以做到：</p>
<ul>
<li>第一种，直接执行     <code>delete from T limit 10000;</code></li>
<li>第二种，在一个连接中循环执行20次 <code>delete from T limit 500;</code></li>
<li>第三种，在20个连接中同时执行    <code>delete from T limit 500</code></li>
</ul>
<p><strong>三种方案分析</strong></p>
<ul>
<li>方案一，事务相对较长，则占用锁的时间较长，会导致其他客户端等待资源时间较长。</li>
<li>方案二，串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作，同时也意味着将资源分片使用（每次执行使用不同片段的资源），可以提高并发性。</li>
<li>方案三，人为自己制造锁竞争，加剧并发量。</li>
</ul>
<h3 id="事务到底是隔离的还是不隔离的"><a href="#事务到底是隔离的还是不隔离的" class="headerlink" title="事务到底是隔离的还是不隔离的"></a>事务到底是隔离的还是不隔离的</h3><ul>
<li><code>innodb</code>支持<code>RC(读提交)</code>和<code>RR(可重复读)</code>隔离级别实现是用的一致性视图(consistent read view)</li>
<li>.事务在启动时会拍一个快照,这个快照是基于整个库的。基于整个库的意思就是说一个事务内,整个库的修改对于该事务都是不可见的(对于快照读的情况)。如果在事务内<code>select t</code>表,另外的事务执行了<code>DDL t</code>表,根据发生时间,<code>要吗锁住要嘛报错</code></li>
</ul>
<p><strong>事务是如何实现的MVCC呢?</strong></p>
<ul>
<li>每个事务都有一个事务ID,叫做<code>transaction id</code>(严格递增)</li>
<li>事务在启动时,找到已提交的最大事务ID记为up_limit_id。</li>
<li>事务在更新一条语句时,比如id=1改为了id=2.会把id=1和该行之前的<code>row trx_id</code>写到<code>undo log</code>里。并且在数据页上把id的值改为2,并且把修改这条语句的<code>transaction id</code>记在该行行头。</li>
<li>再定一个规矩,一个事务要查看一条数据时,必须先用该事务的<code>up_limit_id</code>与该行的<code>transaction id</code>做比对</li>
<li>如果<code>up_limit_id&gt;=transaction id</code>,那么可以看.如果<code>up_limit_id&lt;transaction id</code>,则只能去<code>undo log</code>里去取。去undo log查找数据的时候,也需要做比对,必须<code>up_limit_id&gt;transaction id</code>,才返回数据</li>
</ul>
<p><strong>什么是当前读,</strong></p>
<ul>
<li>由于当前读都是先读后写,只能读当前的值,所以认为当前读.会更新事务内的up_limit_id为该事务的transaction id</li>
</ul>
<p><strong>为什么</strong><code>**RR**</code><strong>能实现可重复读而</strong><code>**RC**</code><strong>不能,分两种情况</strong></p>
<ul>
<li>快照读的情况下,rr(可重复读)不能更新事务内的up_limit_id,而<code>rc(读提交)</code>每次会把<code>up_limit_id</code>更新为快照读之前最新已提交事务的<code>transaction id</code>,则<code>rc(读提交)</code>不能可重复读</li>
<li>当前读的情况下,<code>rr(可重复读)</code>是利用<code>record lock+gap lock</code>来实现的,而<code>rc(读提交)</code>没有gap,所以rc不能可重复读</li>
</ul>
<h3 id="MySQL为什么有时候会选错索引"><a href="#MySQL为什么有时候会选错索引" class="headerlink" title="MySQL为什么有时候会选错索引"></a>MySQL为什么有时候会选错索引</h3><ul>
<li>在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。所以有时候由于MySQL选错了索引，而导致执行速度变得很慢</li>
</ul>
<p>测试代码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB；</span><br></pre></td></tr></table></figure>


<p>然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。</p>
<p>分析一条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;</span><br></pre></td></tr></table></figure>


<p>正常情况下，a上有索引，肯定是要使用索引a的。</p>
<p><img src="https://img-blog.csdnimg.cn/20190414141306715.png#id=OG5aI&originHeight=97&originWidth=1077&originalType=binary&ratio=1&status=done&style=none"><br>但是特许情况下如果同时有两个以下下操作执行：</p>
<ul>
<li>如果一个A请求首先开启了事物，随后，B请求把数据都删除后，又插入了10万行数据。</li>
<li>这时候， B操作的查询语句<code>select * from t where a between 10000 and 20000</code>就不会再选择索引a了，会执行全表扫描，执行时间会比之前慢很多。<code>为什么会出现这样情况？</code>因为选择索引是优化器的工作，而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。</li>
<li>MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。这个统计信息就是索引的“<code>区分度</code>”。一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为<code>“基数”</code>（cardinality）。也就是说，这个基数越大，索引的区分度越好。</li>
<li>可以使用<code>show index table</code>方法，看到一个索引的基数</li>
<li>MySQL是怎样得到索引的基数的呢？MySQL通过采样统计的方法得到基数</li>
<li>如果使用索引a，每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。</li>
<li><code>analyze table t</code> 命令可以用来重新统计索引信息</li>
<li>采用<code>force index</code>强行选择一个索引。如果force index指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190414141504344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=LVEvh&originHeight=321&originWidth=921&originalType=binary&ratio=1&status=done&style=none"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br><span class="line"></span><br><span class="line">第一句，是将慢查询日志的阈值设置为<span class="number">0</span>，表示这个线程接下来的语句都会被记录入慢查询日志中；</span><br><span class="line">第二句，Q1是session B原来的查询；</span><br><span class="line">第三句，Q2是加了force index(a)来和session B原来的查询语句执行情况对比。</span><br></pre></td></tr></table></figure>


<ul>
<li>delete 语句删掉了所有的数据，然后再通过call idata()插入了10万行数据，看上去是覆盖了原来的10万行。</li>
<li>但是，session A开启了事务并没有提交，所以之前插入的10万行数据是不能删除的。这样，之前的数据每一行数据都有两个版本，旧版本是delete之前的数据，新版本是标记为deleted的数据。这样，索引a上的数据其实就有两份</li>
</ul>
<h3 id="怎么给字符串字段加索引"><a href="#怎么给字符串字段加索引" class="headerlink" title="怎么给字符串字段加索引"></a>怎么给字符串字段加索引</h3><ul>
<li>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> SUser(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>), </span><br><span class="line">... </span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>


<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> f1, f2 <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>如果email这个字段上没有索引，那么这个语句就只能做全表扫描。同时，MySQL是支持前缀索引的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</li>
</ul>
<p>比如，这两个在email字段上创建索引的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email);</span><br><span class="line">或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/201904142351118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=FFfQd&originHeight=468&originWidth=1000&originalType=binary&ratio=1&status=done&style=none"><br><img src="https://img-blog.csdnimg.cn/20190414235147183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=XF7LV&originHeight=449&originWidth=640&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>第一个语句创建的index1索引里面，包含了每个记录的整个字符串；</li>
<li>第二个语句创建的index2索引里面，对于每个记录都是只取前6个字节。由于email(6)这个索引结构中每个邮箱字段都只取前6个字节,所以占用的空间会更小，这就是使用前缀索引的优势。但是 可能会增加额外的记录扫描次数。</li>
</ul>
<p><strong>使用的是index1的执行流程</strong></p>
<ul>
<li>从<code>index1</code>索引树找到满足索引值是’<a href="mailto:&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#x79;&#122;&#x40;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#x6d;">&#x7a;&#104;&#x61;&#x6e;&#103;&#115;&#115;&#x78;&#x79;&#122;&#x40;&#x78;&#x78;&#x78;&#x2e;&#x63;&#111;&#x6d;</a>’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=‘<a href="mailto:&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#x40;&#120;&#x78;&#120;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#x68;&#x61;&#110;&#103;&#115;&#x73;&#120;&#x79;&#x7a;&#x40;&#120;&#x78;&#120;&#x2e;&#99;&#x6f;&#x6d;</a>’的条件了，循环结束</li>
<li>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</li>
</ul>
<p><strong>使用的是index2的执行流程</strong></p>
<ul>
<li>从<code>index2</code>索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’<a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#x73;&#120;&#121;&#x7a;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;">&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#x73;&#120;&#121;&#x7a;&#64;&#120;&#x78;&#120;&#46;&#x63;&#x6f;&#x6d;</a>’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
<li>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。</li>
<li>但是  对于这个查询语句来说，如果你定义的<code>index2</code>不是email(6)而是email(7），也就是说取email字段的前7个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到ID2，只扫描一行就结束了。</li>
<li>也就是说<code>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</code>。</li>
</ul>
<p><strong>前缀索引对覆盖索引的影响</strong></p>
<ul>
<li>使用前缀索引可能会增加扫描行数，这会影响到性能。其实，前缀索引的影响不止如此</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询<span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br><span class="line"># 查询<span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> id,name,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。</li>
<li>即使你将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</li>
<li>使用前缀索引就用不上覆盖索引对查询性能的优化了</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。但是，遇到前缀的区分度不够好的情况时。比如，我们国家的身份证号，一共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。</p>
<p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。可能你需要创建长度为12以上的前缀索引，才能够满足区分度要求。但是，<code>索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低</code>。</p>
<p>那么，如果我们能够确定业务需求里面只有按照身份证进行等值查询的需求，还有没有别的处理方法呢？这种方法，既可以占用更小的空间，也能达到相同的查询效率。</p>
<p>第一种方式是使用<code>倒序存储</code>。如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;input_id_card_string&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。</p>
<p>第二种方式是<code>使用hash字段</code>。你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>


<p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以你的查询语句where部分要判断id_card的值是否精确相同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc<span class="operator">=</span>crc32(<span class="string">&#x27;input_id_card_string&#x27;</span>) <span class="keyword">and</span> id_card<span class="operator">=</span><span class="string">&#x27;input_id_card_string&#x27;</span></span><br></pre></td></tr></table></figure>


<p>这样，索引的长度变成了4个字节，比原来小了很多。</p>
<p><strong>使用倒序存储和使用hash字段这两种方法的异同点</strong></p>
<ul>
<li>首先，它们的相同点是，都不支持范围查询。</li>
<li><code>从占用的额外空间来看</code>，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段</li>
<li><code>在CPU消耗方面</code>，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数</li>
<li><code>从查询效率上看</code>，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ul>
<p><strong>字符串字段创建索引的场景你可以使用的方式有：</strong></p>
<ul>
<li>直接创建完整索引，这样可能比较占用空间；</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ul>
<p><strong>利用学号作为登录名索引设计问题？</strong></p>
<blockquote>
<p>如果你在维护一个学校的学生信息数据库，学生登录名的统一格式是”学号@gmail.com”, 而学号的规则是：十五位的数字，其中前三位是所在城市编号、第四到第六位是学校编号、第七位到第十位是入学年份、最后五位是顺序编号。<br>系统登录的时候都需要学生输入登录名和密码，验证正确后才能继续使用系统。就只考虑登录验证这个行为的话，你会怎么设计这个登录名的索引呢？</p>
</blockquote>
<p><code>**设计思路：**</code></p>
<ul>
<li>由于这个学号的规则，无论是正向还是反向的前缀索引，重复度都比较高。因为维护的只是一个学校的，因此前面6位（其中，前三位是所在城市编号、第四到第六位是学校编号）其实是固定的，邮箱后缀都是@gamil.com，因此可以只存入学年份加顺序编号，它们的长度是9位。</li>
<li>而其实在此基础上，可以用数字类型来存这9位数字。比如201100001，这样只需要占4个字节。其实这个就是一种hash，只是它用了最简单的转换规则：字符串转数字的规则，而刚好我们设定的这个背景，可以保证这个转换后结果的唯一性。</li>
</ul>
<h3 id="为什么我的MySQL会“抖”一下"><a href="#为什么我的MySQL会“抖”一下" class="headerlink" title="为什么我的MySQL会“抖”一下"></a>为什么我的MySQL会“抖”一下</h3><ul>
<li>一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下</li>
<li>在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者使用了<code>WAL技术</code>，WAL的全称是Write-Ahead Logging，它的关键点就是<code>先写日志，再写磁盘</code>。</li>
<li>利用WAL技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。但是，由此也带来了内存脏页的问题。脏页会被后台线程自动flush，也会由于数据页淘汰而触发flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些</li>
<li>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</li>
<li>平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（<code>flush</code>）。</li>
</ul>
<p><strong>什么情况会引发数据库的flush过程呢？</strong></p>
<ul>
<li><code>InnoDB</code>在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作redo log（重做日志）。在更新内存写完<code>redo log</code>后，就返回给客户端，本次更新成功。</li>
<li><code>InnoDB</code>的<code>redo log</code>(重做日志)写满了。这时候系统会停止所有更新操作，把<code>checkpoint(检查点)</code>往前推进，<code>redo log</code>留出空间可以继续写</li>
<li>第二种场景是：对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li>
<li>第三种场景就是<code>MySQL</code>认为系统<code>“空闲”</code>的时候。也要见缝插针地找时间，只要有机会就刷一点<code>“脏页”</code></li>
<li>第四种场景就是<code>MySQL正常关闭的情况</code>。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ul>
<p><strong>分析一下上面四种场景对性能的影响</strong></p>
<ul>
<li><code>第一种是“redo log写满了，要flush脏页”</code>，这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为0。</li>
<li><code>第二种是“内存不够用了，要先将脏页写到磁盘”</code>，这种情况其实是常态。InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：第一种是，还没有使用的；第二种是，使用了并且是干净页；第三种是，使用了并且是脏页。InnoDB的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</li>
<li>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</li>
<li>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li>
</ul>
<p><strong>InnoDB刷脏页的控制策略</strong></p>
<ul>
<li>首先，你要正确地告诉<code>InnoDB</code>所在主机的<code>IO能力</code>，这样<code>InnoDB</code>才能知道需要全力刷脏页的时候，可以刷多快。这就要用到<code>innodb_io_capacity</code>这个参数了，它会告诉<code>InnoDB</code>你的磁盘能力。这个值我建议你设置成<code>磁盘的IOPS</code>。</li>
<li>假设有这样一个场景：<code>MySQL的写入速度很慢，TPS很低</code>，但是数据库主机的<code>IO压力并不大</code>。主机磁盘用的是SSD，但是<code>innodb_io_capacity</code>的值设置的是<code>300</code>。于是，InnoDB认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。</li>
<li><code>InnoDB</code>的刷盘速度就是要参考这两个因素：一个是<code>脏页比例</code>，一个是<code>redo log写盘速度</code>。</li>
<li>参数<code>innodb_max_dirty_pages_pct</code>是<code>脏页比例上限</code>，默认值是<code>75%</code>。InnoDB会根据当前的脏页比例（假设为M），算出一个范围在0到100之间的数字。<code>InnoDB</code>每次写入的日志<code>都有一个序号</code>，当前写入的序号跟<code>checkpoint</code>对应的序号之间的差值。我们假设为N。InnoDB会根据这个N算出一个范围在0到100之间的数字，这个计算公式可以记为F2(N)。F2(N)算法比较复杂，你只要知道N越大，算出来的值越大就好了。</li>
<li>然后，根据上述算得的F1(M)和F2(N)两个值，取其中较大的值记为R，之后引擎就可以按照<code>innodb_io_capacity</code>定义的能力乘以<code>R%</code>来控制刷脏页的速度。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019041513510966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=GVQMh&originHeight=1522&originWidth=1142&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>InnoDB会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到MySQL“抖”了一下的原因。</li>
<li>要尽量避免这种情况，你就要合理地设置<code>innodb_io_capacity的值</code>，并且平时要多关注脏页比例，不要让它经常接近<code>75%</code>。</li>
</ul>
<blockquote>
<p>脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到的</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>一旦一个查询请求需要在执行过程中先flush掉一个脏页时，这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</li>
<li>在InnoDB中，<code>innodb_flush_neighbors</code> 参数就是用来控制这个行为的，<code>值为1</code>的时候会有上述的<code>“连坐”机制</code>，<code>值为0时</code>表示不找邻居，自己刷自己的。</li>
<li>找<code>“邻居”</code>这个优化在<code>机械硬盘时代是很有意义</code>的，可以<code>减少很多随机IO</code>。机械硬盘的随机<code>IOPS</code>一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。</li>
<li>而如果使用的是<code>SSD这类IOPS比较高的设备</code>的话，我就建议你把<code>innodb_flush_neighbors</code>的值设置成0。因为这时候<code>IOPS</code>往往不是瓶颈，而<code>“只刷自己”</code>，就能更快地执行完必要的刷脏页操作，减少SQL语句响应时间。</li>
<li>在MySQL 8.0中<code>，innodb_flush_neighbors参数的默认值已经是0</code>了。</li>
</ul>
<h3 id="为什么表数据删掉一半，表文件大小不变"><a href="#为什么表数据删掉一半，表文件大小不变" class="headerlink" title="为什么表数据删掉一半，表文件大小不变"></a>为什么表数据删掉一半，表文件大小不变</h3><ul>
<li>一个InnoDB表包含两部分，即：表结构定义和数据。在MySQL 8.0版本以前，表结构是存在以.frm为后缀的文件里。</li>
<li>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数<code>innodb_file_per_table</code>控制的，设置为<code>OFF</code>表示的是，表的数据放在<code>系统共享表空间</code>，也就是跟数据字典放在一起；设置为<code>ON</code>表示的是，每个InnoDB表数据存储在一个以 <code>.ibd</code>为后缀的文件中。从<code>MySQL 5.6.6</code>版本开始，它的<code>默认值就是ON</code>了</li>
<li>建议你不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过<code>drop table</code>命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</li>
<li>我们在删除整个表的时候，可以使用drop table命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，表中的数据被删除了，但是表空间却没有被回收。</li>
</ul>
<p><strong>数据删除流程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190416104535458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=roWLU&originHeight=478&originWidth=603&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>假设，我们要删掉R4这个记录，InnoDB引擎只会把R4这个记录标记为删除。如果之后要再插入一个ID在300和600之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</li>
<li>InnoDB的数据是按页存储的，那么如果我们删掉了一个数据页上的所有记录，整个数据页就可以被复用了。</li>
<li>但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，比如R4这条记录被删除后，如果插入一个ID是400的行，可以直接复用这个空间。但如果插入的是一个ID是800的行，就不能复用这个位置了。</li>
<li>而当整个页从B+树里面摘掉以后，可以复用到任何位置。如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</li>
<li>所以如果我们用delete命令把整个表的数据删除，结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是<code>“空洞”</code>。</li>
<li>实际上，不止是删除数据会造成空洞，插入数据也会。如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</li>
</ul>
<p><strong>重建表</strong></p>
<ul>
<li>重建表就是新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行一行地从表A里读出来再插入到表B中。由于表B是新建的表，所以表A主键索引上的空洞，在表B中就都不存在了。</li>
<li>可以使用<code>alter table A engine=InnoDB</code>命令来重建表。MySQL 5.5之后会自动完成转存数据、交换表名、删除旧表的操作。</li>
<li>重建表的过程中，如果中途有新的数据要写入，就会造成数据丢失。所以在整个<code>DDL</code>过程中，表A中不能有更新。也就是说，这个DDL不是<code>Online</code>的。在MySQL 5.6版本开始引入的<code>Online DDL</code>，对这个操作流程做了优化。</li>
<li>对于很大的表来说，这个操作是很消耗IO和CPU资源的。想要比较安全的操作的话，推荐使用<code>GitHub</code>开源的<a href="https://github.com/github/gh-ost">gh-ost</a>来做。</li>
</ul>
<p><strong>MySQL执行DDL()原理</strong></p>
<ul>
<li><code>DML</code>：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</li>
<li><code>DDL</code>：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表(TABLE)的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</li>
<li><code>DCL</code>：是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句</li>
<li>MySQL各版本，对于DDL的处理方式是不同的，主要有三种：</li>
<li><code>Copy Table</code>方式：这是InnoDB最早支持的方式。通过临时表拷贝的方式实现的。新建一个带有新结构的临时表，将原表数据全部拷贝到临时表，然后Rename，完成创建操作。这个方式过程中，<code>原表是可读的，不可写</code>。但是<code>会消耗一倍的存储空间</code>。</li>
<li><code>Inplace</code>方式：这是原生MySQL 5.5，以及<code>innodb_plugin</code>中提供的方式。所谓Inplace，也就是在<code>原表上直接进行，不会拷贝临时表</code>。相对于Copy Table方式，这比较高效率。<code>原表同样可读的，但是不可写</code>。</li>
<li><code>Online方式</code>：MySQL 5.6以上版本中提供的方式，无论是Copy Table方式，还是Inplace方式，<code>原表只能允许读取，不可写</code>。对应用有较大的限制，因此MySQL最新版本中，InnoDB支持了所谓的<code>Online方式DDL</code>。与以上两种方式相比，<code>online方式支持DDL时不仅可以读，还可以写</code></li>
</ul>
<h3 id="count-语句到底是怎样实现的"><a href="#count-语句到底是怎样实现的" class="headerlink" title="count(*)语句到底是怎样实现的"></a>count(*)语句到底是怎样实现的</h3><ul>
<li>在不同的MySQL引擎中，count(*)有不同的实现方式。</li>
<li><code>MyISAM引擎</code>把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高。这里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</li>
<li><code>InnoDB引擎</code>就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p><strong>为什么InnoDB不跟MyISAM一样，也把数字存起来呢？</strong></p>
<ul>
<li>这是因为即使是在同一个时刻的多个查询，由于<code>多版本并发控制</code>（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。</li>
<li>这和InnoDB的事务设计有关系，<code>可重复读是它默认的隔离级别</code>，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</li>
<li><code>InnoDB是索引组织表</code>，<code>主键索引树的叶子节点是数据</code>，而<code>普通索引树的叶子节点是主键值</code>。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</li>
<li>MyISAM表虽然count(<em>)很快，但是不支持事务；show table status命令虽然返回很快，但是不准确；InnoDB表直接count(</em>)会遍历全表，虽然结果准确，但会导致性能问题。</li>
</ul>
<h3 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h3><p><code>select count(?) from t</code>这样的查询语句里面，<code>count(*)、count(主键id)、count(字段)和count(1)</code>等不同用法的性能，有哪些差别。</p>
<ul>
<li>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</li>
<li>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</li>
<li><code>对于count(主键id)来说</code>，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。</li>
<li><code>对于count(1)来说</code>，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</li>
<li><code>对于count(字段)来说</code>：如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</li>
<li>count(<em>)是例外：并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>)肯定不是null，按行累加。</li>
<li>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，所以我建议你，尽量使用count(</em>)。</li>
</ul>
<h3 id="order-by是怎么工作的"><a href="#order-by是怎么工作的" class="headerlink" title="order by是怎么工作的"></a>order by是怎么工作的</h3><p>首先创建一个测试表  <code>t_city</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_city` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>


<p>使用存储过程 添加10W条测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">10000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t_city <span class="keyword">values</span>(i,<span class="string">&#x27;广州&#x27;</span>, i,i,i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata2();</span><br></pre></td></tr></table></figure>


<p>比如有如下sql语句，为避免全表扫描，已经在city字段加上索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t_city <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;广州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>


<p>这个语句看上去逻辑很清晰， 那吗数据库内部到底是怎样执行的了？</p>
<p>首先先用<code>explain</code>看看执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> city,name,age <span class="keyword">from</span> t_city <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;广州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/20190416172638203.png#id=J8vpw&originHeight=52&originWidth=981&originalType=binary&ratio=1&status=done&style=none"><br><strong>先看下个执行计划各参数的含义：</strong></p>
<ul>
<li><code>select_type</code>：显 示查询中每个select子句的类型</li>
<li><code>table</code>： 显示这一行的数据是关于哪张表的，有时不是真实的表名字</li>
<li><code>type</code>：在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</li>
<li><code>possible_keys</code>：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li><code>Key</code>：key列显示MySQL实际决定使用的键（索引）</li>
<li><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，不损失精确性的情况下，长度越短越好</li>
<li><code>ref</code>：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><code>rows</code>： 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li><code>Extra</code>：该列包含MySQL解决查询的详细信息。Extra这个字段中的<code>“Using filesort”表示的就是需要排序</code>，MySQL会给每个线程分配一块内存用于排序，称为<code>sort_buffer</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190416174643103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=qZTfO&originHeight=642&originWidth=655&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>按name排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数<code>sort_buffer_size</code>。</li>
<li><code>sort_buffer_size</code>就是MySQL为排序开辟的内存（<code>sort_buffer</code>）的大小。如果要排序的数据量小于sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</li>
</ul>
<blockquote>
<p>确定一个排序语句是否使用了临时文件</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure>


<p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files中看到是否使用了临时文件。</p>
<p><img src="https://img-blog.csdnimg.cn/2019041617592518.png#id=ZWOG8&originHeight=180&originWidth=712&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li><code>number_of_tmp_files</code>表示的是，排序过程中使用的临时文件数。内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</li>
<li>如果<code>sort_buffer_size</code>超过了需要排序的数据量的大小，<code>number_of_tmp_files</code>就是0，表示排序可以直接在内存中完成。否则就需要放在临时文件中排序。</li>
<li><code>sort_buffer_size</code>越小，需要分成的份数越多，<code>number_of_tmp_files</code>的值就越大。</li>
<li><code>sort_mode</code> 里面的<code>packed_additional_fields</code>的意思是，排序过程对字符串做了<code>“紧凑”</code>处理。即使name字段的定义是varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</li>
<li>同时，最后一个查询语句select @b-@a 的返回结果是4000，表示整个执行过程只扫描了4000行。</li>
<li>这里需要注意的是，为了避免对结论造成干扰，我把internal_tmp_disk_storage_engine设置成MyISAM。否则，select @b-@a的结果会大于4000</li>
<li>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在sort_buffer和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么sort_buffer里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</li>
</ul>
<p><strong>如果MySQL认为排序的单行长度太大会怎么做呢？</strong></p>
<ul>
<li><code>max_length_for_sort_data</code>，是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL就认为单行太大，要换一个算法。</li>
</ul>
<h3 id="如何正确地显示随机消息"><a href="#如何正确地显示随机消息" class="headerlink" title="如何正确地显示随机消息"></a>如何正确地显示随机消息</h3><p>从一个单词表中随机选出三个单词</p>
<p>创建测试表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>


<p>添加测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata3();</span><br></pre></td></tr></table></figure>


<p><strong>首先，会想到用order by rand()来实现这个逻辑</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/20190416182846114.png#id=IcAaX&originHeight=98&originWidth=1076&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>Extra字段显示<code>Using temporary</code>，表示的是需要使用临时表；<code>Using filesort</code>，表示的是需要执行排序操作。因此这个Extra的意思就是，需要临时表，并且需要在临时表上排序</li>
<li>order by rand()使用了内存临时表，内存临时表排序的时候使用了rowid排序方法。</li>
<li>tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。如果临时表大小超过了tmp_table_size，那么内存临时表就会转成磁盘临时表。</li>
<li>磁盘临时表使用的引擎默认是InnoDB，是由参数internal_tmp_disk_storage_engine控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的InnoDB表的排序过程。</li>
</ul>
<h3 id="幻读是什么，幻读有什么问题"><a href="#幻读是什么，幻读有什么问题" class="headerlink" title="幻读是什么，幻读有什么问题"></a>幻读是什么，幻读有什么问题</h3><ul>
<li>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</li>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
</ul>
<p><strong>创建测试数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>


<p><strong>下面的语句序列，是怎么加锁的，加的锁又是什么时候释放的呢？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>


<ul>
<li>这个语句会命中d=5的这一行，对应的主键id=5，因此在select 语句执行完成后，id=5这一行会加一个写锁，而且由于两阶段锁协议，这个写锁会在执行commit语句的时候释放。</li>
<li>由于字段d上没有索引，因此这条查询语句会做全表扫描。那么，其他被扫描到的，但是不满足条件的5行记录上，会不会被加锁呢？</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190418165218311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=GPJCV&originHeight=688&originWidth=984&originalType=binary&ratio=1&status=done&style=none"></p>
<ul>
<li>可以看到，session A里执行了三次查询，分别是Q1、Q2和Q3。它们的SQL语句相同，都是select * from t where d=5 for update。这个语句的意思你应该很清楚了，查所有d=5的行，而且使用的是当前读，并且加上写锁</li>
</ul>
<p><strong>图中SQL执行流程</strong></p>
<ul>
<li>Q1只返回id=5这一行；</li>
<li>在T2时刻，session B把id=0这一行的d值改成了5，因此T3时刻Q2查出来的是id=0和id=5这两行；</li>
<li>在T4时刻，session C又插入一行（1,1,5），因此T5时刻Q3查出来的是id=0、id=1和id=5的这三行。</li>
<li>其中，Q3读到id=1这一行的现象，被称为<code>“幻读”</code>。</li>
<li>在<code>可重复读</code>(InnoDB的默认)隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<code>幻读在“当前读”下才会出现。</code></li>
<li>上面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”</li>
</ul>
<p>从事务可见性规则来分析的话，上面这三条SQL语句的返回结果都没有问题。因为这三个查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。并且，session B和sessionC的两条语句，执行后就会提交，所以Q2和Q3就是应该看到这两个事务的操作效果，而且也看到了，这跟事务的可见性规则并不矛盾。但是，这是不是真的没问题呢？</p>
<p><strong>幻读有什么问题？</strong></p>
<ul>
<li>首先是语义上的。session A在T1时刻就声明了，“我要把所有d=5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。</li>
</ul>
<p><strong>其次，是数据一致性的问题。</strong></p>
<ul>
<li>我们知道，锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性</li>
<li>为了说明这个问题，我给session A在T1时刻再加一个更新语句，即：update t set d=100 where d=5。<br><img src="https://img-blog.csdnimg.cn/20190418171046246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=Wyaze&originHeight=551&originWidth=929&originalType=binary&ratio=1&status=done&style=none"><br><strong>上面的执行流程</strong></li>
<li>经过T1时刻，id=5这一行变成 (5,5,100)，当然这个结果最终是在T6时刻正式提交的;</li>
<li>经过T2时刻，id=0这一行变成(0,5,5);</li>
<li>经过T4时刻，表里面多了一行(1,5,5);</li>
</ul>
<p>这样看，这些数据也没啥问题，但是我们再来看看这时候binlog里面的内容。</p>
<ul>
<li>T2时刻，session B事务提交，写入了两条语句；</li>
<li>T4时刻，session C事务提交，写入了两条语句；</li>
<li>T6时刻，session A事务提交，写入了update t set d=100 where d=5 这条语句。</li>
</ul>
<p>放到一起的话，就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> d<span class="operator">=</span><span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。也就是说，id=0和id=1这两行，发生了数据不一致。这个问题很严重，是不行的。</p>
</blockquote>
<p><strong>如何解决幻读？</strong></p>
<ul>
<li>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。</li>
<li>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表t，初始化插入了6个记录，这就产生了7个间隙。</li>
<li>这样，当你执行 select * from t where d=5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</li>
<li>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</li>
<li>间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</li>
<li>间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”</li>
</ul>
<blockquote>
<p>比如现在有这样一个场景 业务逻辑这样的：任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据，代码如下：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span>N <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果行不存在*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(N,N,N);</span><br><span class="line"><span class="comment">/*如果行存在*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d<span class="operator">=</span>N <span class="keyword">set</span> id<span class="operator">=</span>N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>可能你会说，这个不是<code>insert ... on duplicate key update</code> 就能解决吗？但其实在有多个唯一键的时候,这个方法是不能满足要求的。这个逻辑一旦有并发，就会碰到死锁。你一定也觉得奇怪，这个逻辑每次操作前用for update锁起来，已经是最严格的模式了，怎么还会有死锁呢？</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190418172853342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzOTEzNDI=,size_16,color_FFFFFF,t_70#id=n7URX&originHeight=372&originWidth=982&originalType=binary&ratio=1&status=done&style=none"><br>你看到了，其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：</p>
<ul>
<li>session A 执行select … for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);</li>
<li>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</li>
<li>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</li>
<li>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</li>
<li>至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。</li>
</ul>
<blockquote>
<p><code>间隙锁是在可重复读隔离级别下才会生效的</code>。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把<code>binlog</code>格式设置为row。这，也是现在不少公司使用的配置组合。</p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
